{"ast":null,"code":"import _toConsumableArray from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { sortItems } from \"./helpers\";\n/**\n * Columns API\n * @param {Object} instance DataTable instance\n * @param {Mixed} columns  Column index or array of column indexes\n */\n\nexport var Columns = /*#__PURE__*/function () {\n  function Columns(dt) {\n    _classCallCheck(this, Columns);\n\n    this.dt = dt;\n    return this;\n  }\n  /**\n   * Swap two columns\n   * @return {Void}\n   */\n\n\n  _createClass(Columns, [{\n    key: \"swap\",\n    value: function swap(columns) {\n      if (columns.length && columns.length === 2) {\n        var cols = []; // Get the current column indexes\n\n        this.dt.headings.forEach(function (h, i) {\n          cols.push(i);\n        });\n        var x = columns[0];\n        var y = columns[1];\n        var b = cols[y];\n        cols[y] = cols[x];\n        cols[x] = b;\n        this.order(cols);\n      }\n    }\n    /**\n     * Reorder the columns\n     * @return {Array} columns  Array of ordered column indexes\n     */\n\n  }, {\n    key: \"order\",\n    value: function order(columns) {\n      var a;\n      var b;\n      var c;\n      var d;\n      var h;\n      var s;\n      var cell;\n      var temp = [[], [], [], []];\n      var dt = this.dt; // Order the headings\n\n      columns.forEach(function (column, x) {\n        h = dt.headings[column];\n        s = h.getAttribute(\"data-sortable\") !== \"false\";\n        a = h.cloneNode(true);\n        a.originalCellIndex = x;\n        a.sortable = s;\n        temp[0].push(a);\n\n        if (!dt.hiddenColumns.includes(column)) {\n          b = h.cloneNode(true);\n          b.originalCellIndex = x;\n          b.sortable = s;\n          temp[1].push(b);\n        }\n      }); // Order the row cells\n\n      dt.data.forEach(function (row, i) {\n        c = row.cloneNode(false);\n        d = row.cloneNode(false);\n        c.dataIndex = d.dataIndex = i;\n\n        if (row.searchIndex !== null && row.searchIndex !== undefined) {\n          c.searchIndex = d.searchIndex = row.searchIndex;\n        } // Append the cell to the fragment in the correct order\n\n\n        columns.forEach(function (column) {\n          cell = row.cells[column].cloneNode(true);\n          cell.data = row.cells[column].data;\n          c.appendChild(cell);\n\n          if (!dt.hiddenColumns.includes(column)) {\n            cell = row.cells[column].cloneNode(true);\n            cell.data = row.cells[column].data;\n            d.appendChild(cell);\n          }\n        });\n        temp[2].push(c);\n        temp[3].push(d);\n      });\n      dt.headings = temp[0];\n      dt.activeHeadings = temp[1];\n      dt.data = temp[2];\n      dt.activeRows = temp[3]; // Update\n\n      dt.update();\n    }\n    /**\n     * Hide columns\n     * @return {Void}\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide(columns) {\n      if (columns.length) {\n        var dt = this.dt;\n        columns.forEach(function (column) {\n          if (!dt.hiddenColumns.includes(column)) {\n            dt.hiddenColumns.push(column);\n          }\n        });\n        this.rebuild();\n      }\n    }\n    /**\n     * Show columns\n     * @return {Void}\n     */\n\n  }, {\n    key: \"show\",\n    value: function show(columns) {\n      if (columns.length) {\n        var index;\n        var dt = this.dt;\n        columns.forEach(function (column) {\n          index = dt.hiddenColumns.indexOf(column);\n\n          if (index > -1) {\n            dt.hiddenColumns.splice(index, 1);\n          }\n        });\n        this.rebuild();\n      }\n    }\n    /**\n     * Check column(s) visibility\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"visible\",\n    value: function visible(columns) {\n      var cols;\n      var dt = this.dt;\n      columns = columns || dt.headings.map(function (th) {\n        return th.originalCellIndex;\n      });\n\n      if (!isNaN(columns)) {\n        cols = !dt.hiddenColumns.includes(columns);\n      } else if (Array.isArray(columns)) {\n        cols = [];\n        columns.forEach(function (column) {\n          cols.push(!dt.hiddenColumns.includes(column));\n        });\n      }\n\n      return cols;\n    }\n    /**\n     * Add a new column\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      var _this = this;\n\n      var td;\n      var th = document.createElement(\"th\");\n\n      if (!this.dt.headings.length) {\n        this.dt.insert({\n          headings: [data.heading],\n          data: data.data.map(function (i) {\n            return [i];\n          })\n        });\n        this.rebuild();\n        return;\n      }\n\n      if (!this.dt.hiddenHeader) {\n        if (data.heading.nodeName) {\n          th.appendChild(data.heading);\n        } else {\n          th.innerHTML = data.heading;\n        }\n      } else {\n        th.innerHTML = \"\";\n      }\n\n      this.dt.headings.push(th);\n      this.dt.data.forEach(function (row, i) {\n        if (data.data[i]) {\n          td = document.createElement(\"td\");\n\n          if (data.data[i].nodeName) {\n            td.appendChild(data.data[i]);\n          } else {\n            td.innerHTML = data.data[i];\n          }\n\n          td.data = td.innerHTML;\n\n          if (data.render) {\n            td.innerHTML = data.render.call(_this, td.data, td, row);\n          }\n\n          row.appendChild(td);\n        }\n      });\n\n      if (data.type) {\n        th.setAttribute(\"data-type\", data.type);\n      }\n\n      if (data.format) {\n        th.setAttribute(\"data-format\", data.format);\n      }\n\n      if (data.hasOwnProperty(\"sortable\")) {\n        th.sortable = data.sortable;\n        th.setAttribute(\"data-sortable\", data.sortable === true ? \"true\" : \"false\");\n      }\n\n      this.rebuild();\n      this.dt.renderHeader();\n    }\n    /**\n     * Remove column(s)\n     * @param  {Array|Number} select\n     * @return {Void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(select) {\n      var _this2 = this;\n\n      if (Array.isArray(select)) {\n        // Remove in reverse otherwise the indexes will be incorrect\n        select.sort(function (a, b) {\n          return b - a;\n        });\n        select.forEach(function (column) {\n          return _this2.remove(column);\n        });\n      } else {\n        this.dt.headings.splice(select, 1);\n        this.dt.data.forEach(function (row) {\n          row.removeChild(row.cells[select]);\n        });\n      }\n\n      this.rebuild();\n    }\n    /**\n     * Filter by column\n     * @param  {int} column - The column no.\n     * @param  {string} dir - asc or desc\n     * @filter {array} filter - optional parameter with a list of strings\n     * @return {void}\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(column, dir, init, terms) {\n      var dt = this.dt; // Creates a internal state that manages filters if there are none\n\n      if (!dt.filterState) {\n        dt.filterState = {\n          originalData: dt.data\n        };\n      } // If that column is was not filtered yet, we need to create its state\n\n\n      if (!dt.filterState[column]) {\n        // append a filter that selects all rows, 'resetting' the filter\n        var filters = [].concat(_toConsumableArray(terms), [function () {\n          return true;\n        }]);\n\n        dt.filterState[column] = function () {\n          var i = 0;\n          return function () {\n            return filters[i++ % filters.length];\n          };\n        }();\n      } // Apply the filter and rebuild table\n\n\n      var rowFilter = dt.filterState[column](); // fetches next filter\n\n      var filteredRows = Array.from(dt.filterState.originalData).filter(function (tr) {\n        var cell = tr.cells[column];\n        var content = cell.hasAttribute('data-content') ? cell.getAttribute('data-content') : cell.innerText; // If the filter is a function, call it, if it is a string, compare it\n\n        return typeof rowFilter === 'function' ? rowFilter(content) : content === rowFilter;\n      });\n      dt.data = filteredRows;\n      this.rebuild();\n      dt.update();\n\n      if (!init) {\n        dt.emit(\"datatable.sort\", column, dir);\n      }\n    }\n    /**\n     * Sort by column\n     * @param  {int} column - The column no.\n     * @param  {string} dir - asc or desc\n     * @return {void}\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort(column, dir, init) {\n      var _this3 = this;\n\n      var dt = this.dt; // Check column is present\n\n      if (dt.hasHeadings && (column < 0 || column > dt.headings.length)) {\n        return false;\n      } //If there is a filter for this column, apply it instead of sorting\n\n\n      var filterTerms = dt.options.filters && dt.options.filters[dt.headings[column].textContent];\n\n      if (filterTerms && filterTerms.length !== 0) {\n        this.filter(column, dir, init, filterTerms);\n        return;\n      }\n\n      dt.sorting = true;\n\n      if (!init) {\n        dt.emit(\"datatable.sorting\", column, dir);\n      }\n\n      var rows = dt.data;\n      var alpha = [];\n      var numeric = [];\n      var a = 0;\n      var n = 0;\n      var th = dt.headings[column];\n      var waitFor = []; // Check for date format\n\n      if (th.getAttribute(\"data-type\") === \"date\") {\n        var format = false;\n        var formatted = th.hasAttribute(\"data-format\");\n\n        if (formatted) {\n          format = th.getAttribute(\"data-format\");\n        }\n\n        waitFor.push(import(\"./date\").then(function (_ref) {\n          var parseDate = _ref.parseDate;\n          return function (date) {\n            return parseDate(date, format);\n          };\n        }));\n      }\n\n      Promise.all(waitFor).then(function (importedFunctions) {\n        var parseFunction = importedFunctions[0]; // only defined if date\n\n        Array.from(rows).forEach(function (tr) {\n          var cell = tr.cells[column];\n          var content = cell.hasAttribute('data-content') ? cell.getAttribute('data-content') : cell.innerText;\n          var num;\n\n          if (parseFunction) {\n            num = parseFunction(content);\n          } else if (typeof content === \"string\") {\n            num = content.replace(/(\\$|,|\\s|%)/g, \"\");\n          } else {\n            num = content;\n          }\n\n          if (parseFloat(num) == num) {\n            numeric[n++] = {\n              value: Number(num),\n              row: tr\n            };\n          } else {\n            alpha[a++] = {\n              value: typeof content === \"string\" ? content.toLowerCase() : content,\n              row: tr\n            };\n          }\n        });\n        /* Sort according to direction (ascending or descending) */\n\n        if (!dir) {\n          if (th.classList.contains(\"asc\")) {\n            dir = \"desc\";\n          } else {\n            dir = \"asc\";\n          }\n        }\n\n        var top;\n        var btm;\n\n        if (dir == \"desc\") {\n          top = sortItems(alpha, -1);\n          btm = sortItems(numeric, -1);\n          th.classList.remove(\"asc\");\n          th.classList.add(\"desc\");\n        } else {\n          top = sortItems(numeric, 1);\n          btm = sortItems(alpha, 1);\n          th.classList.remove(\"desc\");\n          th.classList.add(\"asc\");\n        }\n        /* Clear asc/desc class names from the last sorted column's th if it isn't the same as the one that was just clicked */\n\n\n        if (dt.lastTh && th != dt.lastTh) {\n          dt.lastTh.classList.remove(\"desc\");\n          dt.lastTh.classList.remove(\"asc\");\n        }\n\n        dt.lastTh = th;\n        /* Reorder the table */\n\n        rows = top.concat(btm);\n        dt.data = [];\n        var indexes = [];\n        rows.forEach(function (v, i) {\n          dt.data.push(v.row);\n\n          if (v.row.searchIndex !== null && v.row.searchIndex !== undefined) {\n            indexes.push(i);\n          }\n        });\n        dt.searchData = indexes;\n\n        _this3.rebuild();\n\n        dt.update();\n\n        if (!init) {\n          dt.emit(\"datatable.sort\", column, dir);\n        }\n      });\n    }\n    /**\n     * Rebuild the columns\n     * @return {Void}\n     */\n\n  }, {\n    key: \"rebuild\",\n    value: function rebuild() {\n      var a;\n      var b;\n      var c;\n      var d;\n      var dt = this.dt;\n      var temp = [];\n      dt.activeRows = [];\n      dt.activeHeadings = [];\n      dt.headings.forEach(function (th, i) {\n        th.originalCellIndex = i;\n        th.sortable = th.getAttribute(\"data-sortable\") !== \"false\";\n\n        if (!dt.hiddenColumns.includes(i)) {\n          dt.activeHeadings.push(th);\n        }\n      }); // Loop over the rows and reorder the cells\n\n      dt.data.forEach(function (row, i) {\n        a = row.cloneNode(false);\n        b = row.cloneNode(false);\n        a.dataIndex = b.dataIndex = i;\n\n        if (row.searchIndex !== null && row.searchIndex !== undefined) {\n          a.searchIndex = b.searchIndex = row.searchIndex;\n        } // Append the cell to the fragment in the correct order\n\n\n        Array.from(row.cells).forEach(function (cell) {\n          c = cell.cloneNode(true);\n          c.data = cell.data;\n          a.appendChild(c);\n\n          if (!dt.hiddenColumns.includes(c.cellIndex)) {\n            d = c.cloneNode(true);\n            d.data = c.data;\n            b.appendChild(d);\n          }\n        }); // Append the fragment with the ordered cells\n\n        temp.push(a);\n        dt.activeRows.push(b);\n      });\n      dt.data = temp;\n      dt.update();\n    }\n  }]);\n\n  return Columns;\n}();","map":null,"metadata":{},"sourceType":"module"}