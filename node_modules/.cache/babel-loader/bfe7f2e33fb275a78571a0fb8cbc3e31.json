{"ast":null,"code":"import _slicedToArray from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/lampp/htdocs/NodeJs/gereja/gereja-fe/shard/Source Files/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Rows } from \"./rows\";\nimport { Columns } from \"./columns\";\nimport { dataToTable } from \"./table\";\nimport { defaultConfig } from \"./config\";\nimport { isObject, isJson, createElement, flush, button, truncate } from \"./helpers\";\nexport var DataTable = /*#__PURE__*/function () {\n  function DataTable(table) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DataTable);\n\n    this.initialized = false; // user options\n\n    this.options = _objectSpread({}, defaultConfig, options, {\n      layout: _objectSpread({}, defaultConfig.layout, options.layout),\n      labels: _objectSpread({}, defaultConfig.labels, options.labels)\n    });\n\n    if (typeof table === \"string\") {\n      table = document.querySelector(table);\n    }\n\n    this.initialLayout = table.innerHTML;\n    this.initialSortable = this.options.sortable; // Disable manual sorting if no header is present (#4)\n\n    if (!this.options.header) {\n      this.options.sortable = false;\n    }\n\n    if (table.tHead === null) {\n      if (!this.options.data || this.options.data && !this.options.data.headings) {\n        this.options.sortable = false;\n      }\n    }\n\n    if (table.tBodies.length && !table.tBodies[0].rows.length) {\n      if (this.options.data) {\n        if (!this.options.data.data) {\n          throw new Error(\"You seem to be using the data option, but you've not defined any rows.\");\n        }\n      }\n    }\n\n    this.table = table;\n    this.listeners = {\n      onResize: function onResize(event) {\n        return _this.onResize(event);\n      }\n    };\n    this.init();\n  }\n  /**\n   * Add custom property or method to extend DataTable\n   * @param  {String} prop    - Method name or property\n   * @param  {Mixed} val      - Function or property value\n   * @return {Void}\n   */\n\n\n  _createClass(DataTable, [{\n    key: \"init\",\n\n    /**\n     * Initialize the instance\n     * @param  {Object} options\n     * @return {Void}\n     */\n    value: function init(options) {\n      var _this2 = this;\n\n      if (this.initialized || this.table.classList.contains(\"dataTable-table\")) {\n        return false;\n      }\n\n      Object.assign(this.options, options || {});\n      this.currentPage = 1;\n      this.onFirstPage = true;\n      this.hiddenColumns = [];\n      this.columnRenderers = [];\n      this.selectedColumns = [];\n      this.render();\n      setTimeout(function () {\n        _this2.emit(\"datatable.init\");\n\n        _this2.initialized = true;\n\n        if (_this2.options.plugins) {\n          Object.entries(_this2.options.plugins).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                plugin = _ref2[0],\n                options = _ref2[1];\n\n            if (_this2[plugin] && typeof _this2[plugin] === \"function\") {\n              _this2[plugin] = _this2[plugin](options, {\n                createElement: createElement\n              }); // Init plugin\n\n              if (options.enabled && _this2[plugin].init && typeof _this2[plugin].init === \"function\") {\n                _this2[plugin].init();\n              }\n            }\n          });\n        }\n      }, 10);\n    }\n    /**\n     * Render the instance\n     * @param  {String} type\n     * @return {Void}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(type) {\n      if (type) {\n        switch (type) {\n          case \"page\":\n            this.renderPage();\n            break;\n\n          case \"pager\":\n            this.renderPager();\n            break;\n\n          case \"header\":\n            this.renderHeader();\n            break;\n        }\n\n        return false;\n      }\n\n      var options = this.options;\n      var template = \"\"; // Convert data to HTML\n\n      if (options.data) {\n        dataToTable.call(this);\n      } // Store references\n\n\n      this.body = this.table.tBodies[0];\n      this.head = this.table.tHead;\n      this.foot = this.table.tFoot;\n\n      if (!this.body) {\n        this.body = createElement(\"tbody\");\n        this.table.appendChild(this.body);\n      }\n\n      this.hasRows = this.body.rows.length > 0; // Make a tHead if there isn't one (fixes #8)\n\n      if (!this.head) {\n        var h = createElement(\"thead\");\n        var t = createElement(\"tr\");\n\n        if (this.hasRows) {\n          Array.from(this.body.rows[0].cells).forEach(function () {\n            t.appendChild(createElement(\"th\"));\n          });\n          h.appendChild(t);\n        }\n\n        this.head = h;\n        this.table.insertBefore(this.head, this.body);\n        this.hiddenHeader = options.hiddenHeader;\n      }\n\n      this.headings = [];\n      this.hasHeadings = this.head.rows.length > 0;\n\n      if (this.hasHeadings) {\n        this.header = this.head.rows[0];\n        this.headings = [].slice.call(this.header.cells);\n      } // Header\n\n\n      if (!options.header) {\n        if (this.head) {\n          this.table.removeChild(this.table.tHead);\n        }\n      } // Footer\n\n\n      if (options.footer) {\n        if (this.head && !this.foot) {\n          this.foot = createElement(\"tfoot\", {\n            html: this.head.innerHTML\n          });\n          this.table.appendChild(this.foot);\n        }\n      } else {\n        if (this.foot) {\n          this.table.removeChild(this.table.tFoot);\n        }\n      } // Build\n\n\n      this.wrapper = createElement(\"div\", {\n        class: \"dataTable-wrapper dataTable-loading\"\n      }); // Template for custom layouts\n\n      template += \"<div class='dataTable-top'>\";\n      template += options.layout.top;\n      template += \"</div>\";\n\n      if (options.scrollY.length) {\n        template += \"<div class='dataTable-container' style='height: \".concat(options.scrollY, \"; overflow-Y: auto;'></div>\");\n      } else {\n        template += \"<div class='dataTable-container'></div>\";\n      }\n\n      template += \"<div class='dataTable-bottom'>\";\n      template += options.layout.bottom;\n      template += \"</div>\"; // Info placement\n\n      template = template.replace(\"{info}\", options.paging ? \"<div class='dataTable-info'></div>\" : \"\"); // Per Page Select\n\n      if (options.paging && options.perPageSelect) {\n        var wrap = \"<div class='dataTable-dropdown'><label>\";\n        wrap += options.labels.perPage;\n        wrap += \"</label></div>\"; // Create the select\n\n        var select = createElement(\"select\", {\n          class: \"dataTable-selector\"\n        }); // Create the options\n\n        options.perPageSelect.forEach(function (val) {\n          var selected = val === options.perPage;\n          var option = new Option(val, val, selected, selected);\n          select.add(option);\n        }); // Custom label\n\n        wrap = wrap.replace(\"{select}\", select.outerHTML); // Selector placement\n\n        template = template.replace(\"{select}\", wrap);\n      } else {\n        template = template.replace(\"{select}\", \"\");\n      } // Searchable\n\n\n      if (options.searchable) {\n        var form = \"<div class='dataTable-search'><input class='dataTable-input' placeholder='\".concat(options.labels.placeholder, \"' type='text'></div>\"); // Search input placement\n\n        template = template.replace(\"{search}\", form);\n      } else {\n        template = template.replace(\"{search}\", \"\");\n      }\n\n      if (this.hasHeadings) {\n        // Sortable\n        this.render(\"header\");\n      } // Add table class\n\n\n      this.table.classList.add(\"dataTable-table\"); // Paginator\n\n      var paginatorWrapper = createElement(\"nav\", {\n        class: \"dataTable-pagination\"\n      });\n      var paginator = createElement(\"ul\", {\n        class: \"dataTable-pagination-list\"\n      });\n      paginatorWrapper.appendChild(paginator); // Pager(s) placement\n\n      template = template.replace(/\\{pager\\}/g, paginatorWrapper.outerHTML);\n      this.wrapper.innerHTML = template;\n      this.container = this.wrapper.querySelector(\".dataTable-container\");\n      this.pagers = this.wrapper.querySelectorAll(\".dataTable-pagination-list\");\n      this.label = this.wrapper.querySelector(\".dataTable-info\"); // Insert in to DOM tree\n\n      this.table.parentNode.replaceChild(this.wrapper, this.table);\n      this.container.appendChild(this.table); // Store the table dimensions\n\n      this.rect = this.table.getBoundingClientRect(); // Convert rows to array for processing\n\n      this.data = Array.from(this.body.rows);\n      this.activeRows = this.data.slice();\n      this.activeHeadings = this.headings.slice(); // Update\n\n      this.update();\n      this.setColumns(); // Fix height\n\n      this.fixHeight(); // Fix columns\n\n      this.fixColumns(); // Class names\n\n      if (!options.header) {\n        this.wrapper.classList.add(\"no-header\");\n      }\n\n      if (!options.footer) {\n        this.wrapper.classList.add(\"no-footer\");\n      }\n\n      if (options.sortable) {\n        this.wrapper.classList.add(\"sortable\");\n      }\n\n      if (options.searchable) {\n        this.wrapper.classList.add(\"searchable\");\n      }\n\n      if (options.fixedHeight) {\n        this.wrapper.classList.add(\"fixed-height\");\n      }\n\n      if (options.fixedColumns) {\n        this.wrapper.classList.add(\"fixed-columns\");\n      }\n\n      this.bindEvents();\n    }\n    /**\n     * Render the page\n     * @return {Void}\n     */\n\n  }, {\n    key: \"renderPage\",\n    value: function renderPage() {\n      var _this3 = this;\n\n      if (this.hasHeadings) {\n        flush(this.header);\n        this.activeHeadings.forEach(function (th) {\n          return _this3.header.appendChild(th);\n        });\n      }\n\n      if (this.hasRows && this.totalPages) {\n        if (this.currentPage > this.totalPages) {\n          this.currentPage = 1;\n        } // Use a fragment to limit touching the DOM\n\n\n        var index = this.currentPage - 1;\n        var frag = document.createDocumentFragment();\n        this.pages[index].forEach(function (row) {\n          return frag.appendChild(_this3.rows().render(row));\n        });\n        this.clear(frag);\n        this.onFirstPage = this.currentPage === 1;\n        this.onLastPage = this.currentPage === this.lastPage;\n      } else {\n        this.setMessage(this.options.labels.noRows);\n      } // Update the info\n\n\n      var current = 0;\n      var f = 0;\n      var t = 0;\n      var items;\n\n      if (this.totalPages) {\n        current = this.currentPage - 1;\n        f = current * this.options.perPage;\n        t = f + this.pages[current].length;\n        f = f + 1;\n        items = this.searching ? this.searchData.length : this.data.length;\n      }\n\n      if (this.label && this.options.labels.info.length) {\n        // CUSTOM LABELS\n        var string = this.options.labels.info.replace(\"{start}\", f).replace(\"{end}\", t).replace(\"{page}\", this.currentPage).replace(\"{pages}\", this.totalPages).replace(\"{rows}\", items);\n        this.label.innerHTML = items ? string : \"\";\n      }\n\n      if (this.currentPage == 1) {\n        this.fixHeight();\n      }\n    }\n    /**\n     * Render the pager(s)\n     * @return {Void}\n     */\n\n  }, {\n    key: \"renderPager\",\n    value: function renderPager() {\n      flush(this.pagers);\n\n      if (this.totalPages > 1) {\n        var c = \"pager\";\n        var frag = document.createDocumentFragment();\n        var prev = this.onFirstPage ? 1 : this.currentPage - 1;\n        var next = this.onLastPage ? this.totalPages : this.currentPage + 1; // first button\n\n        if (this.options.firstLast) {\n          frag.appendChild(button(c, 1, this.options.firstText));\n        } // prev button\n\n\n        if (this.options.nextPrev) {\n          frag.appendChild(button(c, prev, this.options.prevText));\n        }\n\n        var pager = this.links; // truncate the links\n\n        if (this.options.truncatePager) {\n          pager = truncate(this.links, this.currentPage, this.pages.length, this.options.pagerDelta, this.options.ellipsisText);\n        } // active page link\n\n\n        this.links[this.currentPage - 1].classList.add(\"active\"); // append the links\n\n        pager.forEach(function (p) {\n          p.classList.remove(\"active\");\n          frag.appendChild(p);\n        });\n        this.links[this.currentPage - 1].classList.add(\"active\"); // next button\n\n        if (this.options.nextPrev) {\n          frag.appendChild(button(c, next, this.options.nextText));\n        } // first button\n\n\n        if (this.options.firstLast) {\n          frag.appendChild(button(c, this.totalPages, this.options.lastText));\n        } // We may have more than one pager\n\n\n        this.pagers.forEach(function (pager) {\n          pager.appendChild(frag.cloneNode(true));\n        });\n      }\n    }\n    /**\n     * Render the header\n     * @return {Void}\n     */\n\n  }, {\n    key: \"renderHeader\",\n    value: function renderHeader() {\n      var _this4 = this;\n\n      this.labels = [];\n\n      if (this.headings && this.headings.length) {\n        this.headings.forEach(function (th, i) {\n          _this4.labels[i] = th.textContent;\n\n          if (th.firstElementChild && th.firstElementChild.classList.contains(\"dataTable-sorter\")) {\n            th.innerHTML = th.firstElementChild.innerHTML;\n          }\n\n          th.sortable = th.getAttribute(\"data-sortable\") !== \"false\";\n          th.originalCellIndex = i;\n\n          if (_this4.options.sortable && th.sortable) {\n            var link = createElement(\"a\", {\n              href: \"#\",\n              class: \"dataTable-sorter\",\n              html: th.innerHTML\n            });\n            th.innerHTML = \"\";\n            th.setAttribute(\"data-sortable\", \"\");\n            th.appendChild(link);\n          }\n        });\n      }\n\n      this.fixColumns();\n    }\n    /**\n     * Bind event listeners\n     * @return {[type]} [description]\n     */\n\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this5 = this;\n\n      var options = this.options; // Per page selector\n\n      if (options.perPageSelect) {\n        var selector = this.wrapper.querySelector(\".dataTable-selector\");\n\n        if (selector) {\n          // Change per page\n          selector.addEventListener(\"change\", function () {\n            options.perPage = parseInt(selector.value, 10);\n\n            _this5.update();\n\n            _this5.fixHeight();\n\n            _this5.emit(\"datatable.perpage\", options.perPage);\n          }, false);\n        }\n      } // Search input\n\n\n      if (options.searchable) {\n        this.input = this.wrapper.querySelector(\".dataTable-input\");\n\n        if (this.input) {\n          this.input.addEventListener(\"keyup\", function () {\n            return _this5.search(_this5.input.value);\n          }, false);\n        }\n      } // Pager(s) / sorting\n\n\n      this.wrapper.addEventListener(\"click\", function (e) {\n        var t = e.target.closest('a');\n\n        if (t && t.nodeName.toLowerCase() === \"a\") {\n          if (t.hasAttribute(\"data-page\")) {\n            _this5.page(t.getAttribute(\"data-page\"));\n\n            e.preventDefault();\n          } else if (options.sortable && t.classList.contains(\"dataTable-sorter\") && t.parentNode.getAttribute(\"data-sortable\") != \"false\") {\n            _this5.columns().sort(_this5.headings.indexOf(t.parentNode));\n\n            e.preventDefault();\n          }\n        }\n      }, false);\n      window.addEventListener(\"resize\", this.listeners.onResize);\n    }\n    /**\n     * execute on resize\n     */\n\n  }, {\n    key: \"onResize\",\n    value: function onResize() {\n      this.rect = this.container.getBoundingClientRect();\n\n      if (!this.rect.width) {\n        // No longer shown, likely no longer part of DOM. Give up.\n        return;\n      }\n\n      this.fixColumns();\n    }\n    /**\n     * Set up columns\n     * @return {[type]} [description]\n     */\n\n  }, {\n    key: \"setColumns\",\n    value: function setColumns(ajax) {\n      var _this6 = this;\n\n      if (!ajax) {\n        this.data.forEach(function (row) {\n          Array.from(row.cells).forEach(function (cell) {\n            cell.data = cell.innerHTML;\n          });\n        });\n      } // Check for the columns option\n\n\n      if (this.options.columns && this.headings.length) {\n        this.options.columns.forEach(function (data) {\n          // convert single column selection to array\n          if (!Array.isArray(data.select)) {\n            data.select = [data.select];\n          }\n\n          if (data.hasOwnProperty(\"render\") && typeof data.render === \"function\") {\n            _this6.selectedColumns = _this6.selectedColumns.concat(data.select);\n\n            _this6.columnRenderers.push({\n              columns: data.select,\n              renderer: data.render\n            });\n          } // Add the data attributes to the th elements\n\n\n          data.select.forEach(function (column) {\n            var th = _this6.headings[column];\n\n            if (data.type) {\n              th.setAttribute(\"data-type\", data.type);\n            }\n\n            if (data.format) {\n              th.setAttribute(\"data-format\", data.format);\n            }\n\n            if (data.hasOwnProperty(\"sortable\")) {\n              th.setAttribute(\"data-sortable\", data.sortable);\n            }\n\n            if (data.hasOwnProperty(\"hidden\")) {\n              if (data.hidden !== false) {\n                _this6.columns().hide([column]);\n              }\n            }\n\n            if (data.hasOwnProperty(\"sort\") && data.select.length === 1) {\n              _this6.columns().sort(data.select[0], data.sort, true);\n            }\n          });\n        });\n      }\n\n      if (this.hasRows) {\n        this.data.forEach(function (row, i) {\n          row.dataIndex = i;\n          Array.from(row.cells).forEach(function (cell) {\n            cell.data = cell.innerHTML;\n          });\n        });\n\n        if (this.selectedColumns.length) {\n          this.data.forEach(function (row) {\n            Array.from(row.cells).forEach(function (cell, i) {\n              if (_this6.selectedColumns.includes(i)) {\n                _this6.columnRenderers.forEach(function (options) {\n                  if (options.columns.includes(i)) {\n                    cell.innerHTML = options.renderer.call(_this6, cell.data, cell, row);\n                  }\n                });\n              }\n            });\n          });\n        }\n\n        this.columns().rebuild();\n      }\n\n      this.render(\"header\");\n    }\n    /**\n     * Destroy the instance\n     * @return {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.table.innerHTML = this.initialLayout; // Remove the className\n\n      this.table.classList.remove(\"dataTable-table\"); // Remove the containers\n\n      this.wrapper.parentNode.replaceChild(this.table, this.wrapper);\n      this.initialized = false;\n      window.removeEventListener(\"resize\", this.listeners.onResize);\n    }\n    /**\n     * Update the instance\n     * @return {Void}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.wrapper.classList.remove(\"dataTable-empty\");\n      this.paginate(this);\n      this.render(\"page\");\n      this.links = [];\n      var i = this.pages.length;\n\n      while (i--) {\n        var num = i + 1;\n        this.links[i] = button(i === 0 ? \"active\" : \"\", num, num);\n      }\n\n      this.sorting = false;\n      this.render(\"pager\");\n      this.rows().update();\n      this.emit(\"datatable.update\");\n    }\n    /**\n     * Sort rows into pages\n     * @return {Number}\n     */\n\n  }, {\n    key: \"paginate\",\n    value: function paginate() {\n      var _this7 = this;\n\n      var perPage = this.options.perPage;\n      var rows = this.activeRows;\n\n      if (this.searching) {\n        rows = [];\n        this.searchData.forEach(function (index) {\n          return rows.push(_this7.activeRows[index]);\n        });\n      }\n\n      if (this.options.paging) {\n        // Check for hidden columns\n        this.pages = rows.map(function (tr, i) {\n          return i % perPage === 0 ? rows.slice(i, i + perPage) : null;\n        }).filter(function (page) {\n          return page;\n        });\n      } else {\n        this.pages = [rows];\n      }\n\n      this.totalPages = this.lastPage = this.pages.length;\n      return this.totalPages;\n    }\n    /**\n     * Fix column widths\n     * @return {Void}\n     */\n\n  }, {\n    key: \"fixColumns\",\n    value: function fixColumns() {\n      var _this8 = this;\n\n      if ((this.options.scrollY.length || this.options.fixedColumns) && this.activeHeadings && this.activeHeadings.length) {\n        var cells;\n        var hd = false;\n        this.columnWidths = []; // If we have headings we need only set the widths on them\n        // otherwise we need a temp header and the widths need applying to all cells\n\n        if (this.table.tHead) {\n          if (this.options.scrollY.length) {\n            hd = createElement(\"thead\");\n            hd.appendChild(createElement(\"tr\"));\n            hd.style.height = '0px';\n\n            if (this.headerTable) {\n              // move real header back into place\n              this.table.tHead = this.headerTable.tHead;\n            }\n          } // Reset widths\n\n\n          this.activeHeadings.forEach(function (cell) {\n            cell.style.width = \"\";\n          });\n          this.activeHeadings.forEach(function (cell, i) {\n            var ow = cell.offsetWidth;\n            var w = ow / _this8.rect.width * 100;\n            cell.style.width = \"\".concat(w, \"%\");\n            _this8.columnWidths[i] = ow;\n\n            if (_this8.options.scrollY.length) {\n              var th = createElement(\"th\");\n              hd.firstElementChild.appendChild(th);\n              th.style.width = \"\".concat(w, \"%\");\n              th.style.paddingTop = \"0\";\n              th.style.paddingBottom = \"0\";\n              th.style.border = \"0\";\n            }\n          });\n\n          if (this.options.scrollY.length) {\n            var container = this.table.parentElement;\n\n            if (!this.headerTable) {\n              this.headerTable = createElement(\"table\", {\n                class: \"dataTable-table\"\n              });\n              var headercontainer = createElement(\"div\", {\n                class: \"dataTable-headercontainer\"\n              });\n              headercontainer.appendChild(this.headerTable);\n              container.parentElement.insertBefore(headercontainer, container);\n            }\n\n            var thd = this.table.tHead;\n            this.table.replaceChild(hd, thd);\n            this.headerTable.tHead = thd; // Compensate for scrollbars.\n\n            this.headerTable.parentElement.style.paddingRight = \"\".concat(this.headerTable.clientWidth - this.table.clientWidth + parseInt(this.headerTable.parentElement.style.paddingRight || '0', 10), \"px\");\n\n            if (container.scrollHeight > container.clientHeight) {\n              // scrollbars on one page means scrollbars on all pages.\n              container.style.overflowY = 'scroll';\n            }\n          }\n        } else {\n          cells = []; // Make temperary headings\n\n          hd = createElement(\"thead\");\n          var r = createElement(\"tr\");\n          Array.from(this.table.tBodies[0].rows[0].cells).forEach(function () {\n            var th = createElement(\"th\");\n            r.appendChild(th);\n            cells.push(th);\n          });\n          hd.appendChild(r);\n          this.table.insertBefore(hd, this.body);\n          var widths = [];\n          cells.forEach(function (cell, i) {\n            var ow = cell.offsetWidth;\n            var w = ow / _this8.rect.width * 100;\n            widths.push(w);\n            _this8.columnWidths[i] = ow;\n          });\n          this.data.forEach(function (row) {\n            Array.from(row.cells).forEach(function (cell, i) {\n              if (_this8.columns(cell.cellIndex).visible()) cell.style.width = \"\".concat(widths[i], \"%\");\n            });\n          }); // Discard the temp header\n\n          this.table.removeChild(hd);\n        }\n      }\n    }\n    /**\n     * Fix the container height\n     * @return {Void}\n     */\n\n  }, {\n    key: \"fixHeight\",\n    value: function fixHeight() {\n      if (this.options.fixedHeight) {\n        this.container.style.height = null;\n        this.rect = this.container.getBoundingClientRect();\n        this.container.style.height = \"\".concat(this.rect.height, \"px\");\n      }\n    }\n    /**\n     * Perform a search of the data set\n     * @param  {string} query\n     * @return {void}\n     */\n\n  }, {\n    key: \"search\",\n    value: function search(query) {\n      var _this9 = this;\n\n      if (!this.hasRows) return false;\n      query = query.toLowerCase();\n      this.currentPage = 1;\n      this.searching = true;\n      this.searchData = [];\n\n      if (!query.length) {\n        this.searching = false;\n        this.update();\n        this.emit(\"datatable.search\", query, this.searchData);\n        this.wrapper.classList.remove(\"search-results\");\n        return false;\n      }\n\n      this.clear();\n      this.data.forEach(function (row, idx) {\n        var inArray = _this9.searchData.includes(row); // https://github.com/Mobius1/Vanilla-DataTables/issues/12\n\n\n        var doesQueryMatch = query.split(\" \").reduce(function (bool, word) {\n          var includes = false;\n          var cell = null;\n          var content = null;\n\n          for (var x = 0; x < row.cells.length; x++) {\n            cell = row.cells[x];\n            content = cell.hasAttribute('data-content') ? cell.getAttribute('data-content') : cell.textContent;\n\n            if (content.toLowerCase().includes(word) && _this9.columns(cell.cellIndex).visible()) {\n              includes = true;\n              break;\n            }\n          }\n\n          return bool && includes;\n        }, true);\n\n        if (doesQueryMatch && !inArray) {\n          row.searchIndex = idx;\n\n          _this9.searchData.push(idx);\n        } else {\n          row.searchIndex = null;\n        }\n      });\n      this.wrapper.classList.add(\"search-results\");\n\n      if (!this.searchData.length) {\n        this.wrapper.classList.remove(\"search-results\");\n        this.setMessage(this.options.labels.noRows);\n      } else {\n        this.update();\n      }\n\n      this.emit(\"datatable.search\", query, this.searchData);\n    }\n    /**\n     * Change page\n     * @param  {int} page\n     * @return {void}\n     */\n\n  }, {\n    key: \"page\",\n    value: function page(_page) {\n      // We don't want to load the current page again.\n      if (_page == this.currentPage) {\n        return false;\n      }\n\n      if (!isNaN(_page)) {\n        this.currentPage = parseInt(_page, 10);\n      }\n\n      if (_page > this.pages.length || _page < 0) {\n        return false;\n      }\n\n      this.render(\"page\");\n      this.render(\"pager\");\n      this.emit(\"datatable.page\", _page);\n    }\n    /**\n     * Sort by column\n     * @param  {int} column - The column no.\n     * @param  {string} direction - asc or desc\n     * @return {void}\n     */\n\n  }, {\n    key: \"sortColumn\",\n    value: function sortColumn(column, direction) {\n      // Use columns API until sortColumn method is removed\n      this.columns().sort(column, direction);\n    }\n    /**\n     * Add new row data\n     * @param {object} data\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(data) {\n      var _this10 = this;\n\n      var rows = [];\n\n      if (isObject(data)) {\n        if (data.headings) {\n          if (!this.hasHeadings && !this.hasRows) {\n            var tr = createElement(\"tr\");\n            data.headings.forEach(function (heading) {\n              var th = createElement(\"th\", {\n                html: heading\n              });\n              tr.appendChild(th);\n            });\n            this.head.appendChild(tr);\n            this.header = tr;\n            this.headings = [].slice.call(tr.cells);\n            this.hasHeadings = true; // Re-enable sorting if it was disabled due\n            // to missing header\n\n            this.options.sortable = this.initialSortable; // Allow sorting on new header\n\n            this.render(\"header\"); // Activate newly added headings\n\n            this.activeHeadings = this.headings.slice();\n          }\n        }\n\n        if (data.data && Array.isArray(data.data)) {\n          rows = data.data;\n        }\n      } else if (Array.isArray(data)) {\n        data.forEach(function (row) {\n          var r = [];\n          Object.entries(row).forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                heading = _ref4[0],\n                cell = _ref4[1];\n\n            var index = _this10.labels.indexOf(heading);\n\n            if (index > -1) {\n              r[index] = cell;\n            }\n          });\n          rows.push(r);\n        });\n      }\n\n      if (rows.length) {\n        this.rows().add(rows);\n        this.hasRows = true;\n      }\n\n      this.update();\n      this.setColumns();\n      this.fixColumns();\n    }\n    /**\n     * Refresh the instance\n     * @return {void}\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      if (this.options.searchable) {\n        this.input.value = \"\";\n        this.searching = false;\n      }\n\n      this.currentPage = 1;\n      this.onFirstPage = true;\n      this.update();\n      this.emit(\"datatable.refresh\");\n    }\n    /**\n     * Truncate the table\n     * @param  {mixes} html - HTML string or HTMLElement\n     * @return {void}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(html) {\n      if (this.body) {\n        flush(this.body);\n      }\n\n      var parent = this.body;\n\n      if (!this.body) {\n        parent = this.table;\n      }\n\n      if (html) {\n        if (typeof html === \"string\") {\n          var frag = document.createDocumentFragment();\n          frag.innerHTML = html;\n        }\n\n        parent.appendChild(html);\n      }\n    }\n    /**\n     * Export table to various formats (csv, txt or sql)\n     * @param  {Object} userOptions User options\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"export\",\n    value: function _export(userOptions) {\n      if (!this.hasHeadings && !this.hasRows) return false;\n      var headers = this.activeHeadings;\n      var rows = [];\n      var arr = [];\n      var i;\n      var x;\n      var str;\n      var link;\n      var defaults = {\n        download: true,\n        skipColumn: [],\n        // csv\n        lineDelimiter: \"\\n\",\n        columnDelimiter: \",\",\n        // sql\n        tableName: \"myTable\",\n        // json\n        replacer: null,\n        space: 4\n      }; // Check for the options object\n\n      if (!isObject(userOptions)) {\n        return false;\n      }\n\n      var options = _objectSpread({}, defaults, userOptions);\n\n      if (options.type) {\n        if (options.type === \"txt\" || options.type === \"csv\") {\n          // Include headings\n          rows[0] = this.header;\n        } // Selection or whole table\n\n\n        if (options.selection) {\n          // Page number\n          if (!isNaN(options.selection)) {\n            rows = rows.concat(this.pages[options.selection - 1]);\n          } else if (Array.isArray(options.selection)) {\n            // Array of page numbers\n            for (i = 0; i < options.selection.length; i++) {\n              rows = rows.concat(this.pages[options.selection[i] - 1]);\n            }\n          }\n        } else {\n          rows = rows.concat(this.activeRows);\n        } // Only proceed if we have data\n\n\n        if (rows.length) {\n          if (options.type === \"txt\" || options.type === \"csv\") {\n            str = \"\";\n\n            for (i = 0; i < rows.length; i++) {\n              for (x = 0; x < rows[i].cells.length; x++) {\n                // Check for column skip and visibility\n                if (!options.skipColumn.includes(headers[x].originalCellIndex) && this.columns(headers[x].originalCellIndex).visible()) {\n                  var text = rows[i].cells[x].textContent;\n                  text = text.trim();\n                  text = text.replace(/\\s{2,}/g, ' ');\n                  text = text.replace(/\\n/g, '  ');\n                  text = text.replace(/\"/g, '\"\"'); //have to manually encode \"#\" as encodeURI leaves it as is.\n\n                  text = text.replace(/#/g, \"%23\");\n                  if (text.includes(\",\")) text = \"\\\"\".concat(text, \"\\\"\");\n                  str += text + options.columnDelimiter;\n                }\n              } // Remove trailing column delimiter\n\n\n              str = str.trim().substring(0, str.length - 1); // Apply line delimiter\n\n              str += options.lineDelimiter;\n            } // Remove trailing line delimiter\n\n\n            str = str.trim().substring(0, str.length - 1);\n\n            if (options.download) {\n              str = \"data:text/csv;charset=utf-8,\".concat(str);\n            }\n          } else if (options.type === \"sql\") {\n            // Begin INSERT statement\n            str = \"INSERT INTO `\".concat(options.tableName, \"` (\"); // Convert table headings to column names\n\n            for (i = 0; i < headers.length; i++) {\n              // Check for column skip and column visibility\n              if (!options.skipColumn.includes(headers[i].originalCellIndex) && this.columns(headers[i].originalCellIndex).visible()) {\n                str += \"`\".concat(headers[i].textContent, \"`,\");\n              }\n            } // Remove trailing comma\n\n\n            str = str.trim().substring(0, str.length - 1); // Begin VALUES\n\n            str += \") VALUES \"; // Iterate rows and convert cell data to column values\n\n            for (i = 0; i < rows.length; i++) {\n              str += \"(\";\n\n              for (x = 0; x < rows[i].cells.length; x++) {\n                // Check for column skip and column visibility\n                if (!options.skipColumn.includes(headers[x].originalCellIndex) && this.columns(headers[x].originalCellIndex).visible()) {\n                  str += \"\\\"\".concat(rows[i].cells[x].textContent, \"\\\",\");\n                }\n              } // Remove trailing comma\n\n\n              str = str.trim().substring(0, str.length - 1); // end VALUES\n\n              str += \"),\";\n            } // Remove trailing comma\n\n\n            str = str.trim().substring(0, str.length - 1); // Add trailing colon\n\n            str += \";\";\n\n            if (options.download) {\n              str = \"data:application/sql;charset=utf-8,\".concat(str);\n            }\n          } else if (options.type === \"json\") {\n            // Iterate rows\n            for (x = 0; x < rows.length; x++) {\n              arr[x] = arr[x] || {}; // Iterate columns\n\n              for (i = 0; i < headers.length; i++) {\n                // Check for column skip and column visibility\n                if (!options.skipColumn.includes(headers[i].originalCellIndex) && this.columns(headers[i].originalCellIndex).visible()) {\n                  arr[x][headers[i].textContent] = rows[x].cells[i].textContent;\n                }\n              }\n            } // Convert the array of objects to JSON string\n\n\n            str = JSON.stringify(arr, options.replacer, options.space);\n\n            if (options.download) {\n              str = \"data:application/json;charset=utf-8,\".concat(str);\n            }\n          } // Download\n\n\n          if (options.download) {\n            // Filename\n            options.filename = options.filename || \"datatable_export\";\n            options.filename += \".\".concat(options.type);\n            str = encodeURI(str); // Create a link to trigger the download\n\n            link = document.createElement(\"a\");\n            link.href = str;\n            link.download = options.filename; // Append the link\n\n            document.body.appendChild(link); // Trigger the download\n\n            link.click(); // Remove the link\n\n            document.body.removeChild(link);\n          }\n\n          return str;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Import data to the table\n     * @param  {Object} userOptions User options\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"import\",\n    value: function _import(userOptions) {\n      var obj = false;\n      var defaults = {\n        // csv\n        lineDelimiter: \"\\n\",\n        columnDelimiter: \",\"\n      }; // Check for the options object\n\n      if (!isObject(userOptions)) {\n        return false;\n      }\n\n      var options = _objectSpread({}, defaults, userOptions);\n\n      if (options.data.length || isObject(options.data)) {\n        // Import CSV\n        if (options.type === \"csv\") {\n          obj = {\n            data: []\n          }; // Split the string into rows\n\n          var rows = options.data.split(options.lineDelimiter);\n\n          if (rows.length) {\n            if (options.headings) {\n              obj.headings = rows[0].split(options.columnDelimiter);\n              rows.shift();\n            }\n\n            rows.forEach(function (row, i) {\n              obj.data[i] = []; // Split the rows into values\n\n              var values = row.split(options.columnDelimiter);\n\n              if (values.length) {\n                values.forEach(function (value) {\n                  obj.data[i].push(value);\n                });\n              }\n            });\n          }\n        } else if (options.type === \"json\") {\n          var json = isJson(options.data); // Valid JSON string\n\n          if (json) {\n            obj = {\n              headings: [],\n              data: []\n            };\n            json.forEach(function (data, i) {\n              obj.data[i] = [];\n              Object.entries(data).forEach(function (_ref5) {\n                var _ref6 = _slicedToArray(_ref5, 2),\n                    column = _ref6[0],\n                    value = _ref6[1];\n\n                if (!obj.headings.includes(column)) {\n                  obj.headings.push(column);\n                }\n\n                obj.data[i].push(value);\n              });\n            });\n          } else {// console.warn(\"That's not valid JSON!\")\n          }\n        }\n\n        if (isObject(options.data)) {\n          obj = options.data;\n        }\n\n        if (obj) {\n          // Add the rows\n          this.insert(obj);\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Print the table\n     * @return {void}\n     */\n\n  }, {\n    key: \"print\",\n    value: function print() {\n      var headings = this.activeHeadings;\n      var rows = this.activeRows;\n      var table = createElement(\"table\");\n      var thead = createElement(\"thead\");\n      var tbody = createElement(\"tbody\");\n      var tr = createElement(\"tr\");\n      headings.forEach(function (th) {\n        tr.appendChild(createElement(\"th\", {\n          html: th.textContent\n        }));\n      });\n      thead.appendChild(tr);\n      rows.forEach(function (row) {\n        var tr = createElement(\"tr\");\n        Array.from(row.cells).forEach(function (cell) {\n          tr.appendChild(createElement(\"td\", {\n            html: cell.textContent\n          }));\n        });\n        tbody.appendChild(tr);\n      });\n      table.appendChild(thead);\n      table.appendChild(tbody); // Open new window\n\n      var w = window.open(); // Append the table to the body\n\n      w.document.body.appendChild(table); // Print\n\n      w.print();\n    }\n    /**\n     * Show a message in the table\n     * @param {string} message\n     */\n\n  }, {\n    key: \"setMessage\",\n    value: function setMessage(message) {\n      var colspan = 1;\n\n      if (this.hasRows) {\n        colspan = this.data[0].cells.length;\n      } else if (this.activeHeadings.length) {\n        colspan = this.activeHeadings.length;\n      }\n\n      this.wrapper.classList.add(\"dataTable-empty\");\n\n      if (this.label) {\n        this.label.innerHTML = \"\";\n      }\n\n      this.totalPages = 0;\n      this.render(\"pager\");\n      this.clear(createElement(\"tr\", {\n        html: \"<td class=\\\"dataTables-empty\\\" colspan=\\\"\".concat(colspan, \"\\\">\").concat(message, \"</td>\")\n      }));\n    }\n    /**\n     * Columns API access\n     * @return {Object} new Columns instance\n     */\n\n  }, {\n    key: \"columns\",\n    value: function columns(_columns) {\n      return new Columns(this, _columns);\n    }\n    /**\n     * Rows API access\n     * @return {Object} new Rows instance\n     */\n\n  }, {\n    key: \"rows\",\n    value: function rows(_rows) {\n      return new Rows(this, _rows);\n    }\n    /**\n     * Add custom event listener\n     * @param  {String} event\n     * @param  {Function} callback\n     * @return {Void}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.events = this.events || {};\n      this.events[event] = this.events[event] || [];\n      this.events[event].push(callback);\n    }\n    /**\n     * Remove custom event listener\n     * @param  {String} event\n     * @param  {Function} callback\n     * @return {Void}\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      this.events = this.events || {};\n      if (event in this.events === false) return;\n      this.events[event].splice(this.events[event].indexOf(callback), 1);\n    }\n    /**\n     * Fire custom event\n     * @param  {String} event\n     * @return {Void}\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      this.events = this.events || {};\n      if (event in this.events === false) return;\n\n      for (var i = 0; i < this.events[event].length; i++) {\n        this.events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n    }\n  }], [{\n    key: \"extend\",\n    value: function extend(prop, val) {\n      if (typeof val === \"function\") {\n        DataTable.prototype[prop] = val;\n      } else {\n        DataTable[prop] = val;\n      }\n    }\n  }]);\n\n  return DataTable;\n}();","map":null,"metadata":{},"sourceType":"module"}