{"ast":null,"code":"/*!\r\n *\r\n * Vanilla-DataTables\r\n * Copyright (c) 2015-2017 Karl Saunders (http://mobius.ovh)\r\n * Licensed under MIT (http://www.opensource.org/licenses/mit-license.php)\r\n *\r\n * Version: 1.6.16\r\n *\r\n */\n(function (root, factory) {\n  var plugin = \"DataTable\";\n\n  if (typeof exports === \"object\") {\n    module.exports = factory(plugin);\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], factory(plugin));\n  } else {\n    root[plugin] = factory(plugin);\n  }\n})(typeof global !== 'undefined' ? global : this.window || this.global, function (plugin) {\n  \"use strict\";\n\n  var win = window,\n      doc = document,\n      body = doc.body;\n  /**\r\n   * Default configuration\r\n   * @typ {Object}\r\n   */\n\n  var defaultConfig = {\n    perPage: 10,\n    perPageSelect: [5, 10, 15, 20, 25],\n    sortable: true,\n    searchable: true,\n    // Pagination\n    nextPrev: true,\n    firstLast: false,\n    prevText: \"&lsaquo;\",\n    nextText: \"&rsaquo;\",\n    firstText: \"&laquo;\",\n    lastText: \"&raquo;\",\n    ellipsisText: \"&hellip;\",\n    ascText: \"▴\",\n    descText: \"▾\",\n    truncatePager: true,\n    pagerDelta: 2,\n    fixedColumns: true,\n    fixedHeight: false,\n    header: true,\n    footer: false,\n    // Customise the display text\n    labels: {\n      placeholder: \"Search...\",\n      // The search input placeholder\n      perPage: \"{select} entries per page\",\n      // per-page dropdown label\n      noRows: \"No entries found\",\n      // Message shown when there are no search results\n      info: \"Showing {start} to {end} of {rows} entries\" //\n\n    },\n    // Customise the layout\n    layout: {\n      top: \"{select}{search}\",\n      bottom: \"{info}{pager}\"\n    }\n  };\n  /**\r\n   * Check is item is object\r\n   * @return {Boolean}\r\n   */\n\n  var isObject = function isObject(val) {\n    return Object.prototype.toString.call(val) === \"[object Object]\";\n  };\n  /**\r\n   * Check is item is array\r\n   * @return {Boolean}\r\n   */\n\n\n  var isArray = function isArray(val) {\n    return Array.isArray(val);\n  };\n  /**\r\n   * Check for valid JSON string\r\n   * @param  {String}   str\r\n   * @return {Boolean|Array|Object}\r\n   */\n\n\n  var isJson = function isJson(str) {\n    var t = !1;\n\n    try {\n      t = JSON.parse(str);\n    } catch (e) {\n      return !1;\n    }\n\n    return !(null === t || !isArray(t) && !isObject(t)) && t;\n  };\n  /**\r\n   * Merge objects (reccursive)\r\n   * @param  {Object} r\r\n   * @param  {Object} t\r\n   * @return {Object}\r\n   */\n\n\n  var extend = function extend(src, props) {\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop)) {\n        var val = props[prop];\n\n        if (val && isObject(val)) {\n          src[prop] = src[prop] || {};\n          extend(src[prop], val);\n        } else {\n          src[prop] = val;\n        }\n      }\n    }\n\n    return src;\n  };\n  /**\r\n   * Iterator helper\r\n   * @param  {(Array|Object)}   arr     Any object, array or array-like collection.\r\n   * @param  {Function}         fn      Callback\r\n   * @param  {Object}           scope   Change the value of this\r\n   * @return {Void}\r\n   */\n\n\n  var each = function each(arr, fn, scope) {\n    var n;\n\n    if (isObject(arr)) {\n      for (n in arr) {\n        if (Object.prototype.hasOwnProperty.call(arr, n)) {\n          fn.call(scope, arr[n], n);\n        }\n      }\n    } else {\n      for (n = 0; n < arr.length; n++) {\n        fn.call(scope, arr[n], n);\n      }\n    }\n  };\n  /**\r\n   * Add event listener to target\r\n   * @param  {Object} el\r\n   * @param  {String} e\r\n   * @param  {Function} fn\r\n   */\n\n\n  var on = function on(el, e, fn) {\n    el.addEventListener(e, fn, false);\n  };\n  /**\r\n   * Create DOM element node\r\n   * @param  {String}   a nodeName\r\n   * @param  {Object}   b properties and attributes\r\n   * @return {Object}\r\n   */\n\n\n  var createElement = function createElement(a, b) {\n    var d = doc.createElement(a);\n\n    if (b && \"object\" == typeof b) {\n      var e;\n\n      for (e in b) {\n        if (\"html\" === e) {\n          d.innerHTML = b[e];\n        } else {\n          d.setAttribute(e, b[e]);\n        }\n      }\n    }\n\n    return d;\n  };\n\n  var flush = function flush(el, ie) {\n    if (el instanceof NodeList) {\n      each(el, function (e) {\n        flush(e, ie);\n      });\n    } else {\n      if (ie) {\n        while (el.hasChildNodes()) {\n          el.removeChild(el.firstChild);\n        }\n      } else {\n        el.innerHTML = \"\";\n      }\n    }\n  };\n  /**\r\n   * Create button helper\r\n   * @param  {String}   c\r\n   * @param  {Number}   p\r\n   * @param  {String}   t\r\n   * @return {Object}\r\n   */\n\n\n  var button = function button(c, p, t) {\n    return createElement(\"li\", {\n      class: c,\n      html: '<a href=\"#\" data-page=\"' + p + '\">' + t + \"</a>\"\n    });\n  };\n  /**\r\n   * classList shim\r\n   * @type {Object}\r\n   */\n\n\n  var classList = {\n    add: function add(s, a) {\n      if (s.classList) {\n        s.classList.add(a);\n      } else {\n        if (!classList.contains(s, a)) {\n          s.className = s.className.trim() + \" \" + a;\n        }\n      }\n    },\n    remove: function remove(s, a) {\n      if (s.classList) {\n        s.classList.remove(a);\n      } else {\n        if (classList.contains(s, a)) {\n          s.className = s.className.replace(new RegExp(\"(^|\\\\s)\" + a.split(\" \").join(\"|\") + \"(\\\\s|$)\", \"gi\"), \" \");\n        }\n      }\n    },\n    contains: function contains(s, a) {\n      if (s) return s.classList ? s.classList.contains(a) : !!s.className && !!s.className.match(new RegExp(\"(\\\\s|^)\" + a + \"(\\\\s|$)\"));\n    }\n  };\n  /**\r\n   * Bubble sort algorithm\r\n   */\n\n  var sortItems = function sortItems(a, b) {\n    var c, d;\n\n    if (1 === b) {\n      c = 0;\n      d = a.length;\n    } else {\n      if (b === -1) {\n        c = a.length - 1;\n        d = -1;\n      }\n    }\n\n    for (var e = !0; e;) {\n      e = !1;\n\n      for (var f = c; f != d; f += b) {\n        if (a[f + b] && a[f].value > a[f + b].value) {\n          var g = a[f],\n              h = a[f + b],\n              i = g;\n          a[f] = h;\n          a[f + b] = i;\n          e = !0;\n        }\n      }\n    }\n\n    return a;\n  };\n  /**\r\n   * Pager truncation algorithm\r\n   */\n\n\n  var truncate = function truncate(a, b, c, d, ellipsis) {\n    d = d || 2;\n    var j,\n        e = 2 * d,\n        f = b - d,\n        g = b + d,\n        h = [],\n        i = [];\n\n    if (b < 4 - d + e) {\n      g = 3 + e;\n    } else if (b > c - (3 - d + e)) {\n      f = c - (2 + e);\n    }\n\n    for (var k = 1; k <= c; k++) {\n      if (1 == k || k == c || k >= f && k <= g) {\n        var l = a[k - 1];\n        classList.remove(l, \"active\");\n        h.push(l);\n      }\n    }\n\n    each(h, function (c) {\n      var d = c.children[0].getAttribute(\"data-page\");\n\n      if (j) {\n        var e = j.children[0].getAttribute(\"data-page\");\n        if (d - e == 2) i.push(a[e]);else if (d - e != 1) {\n          var f = createElement(\"li\", {\n            class: \"ellipsis\",\n            html: '<a href=\"#\">' + ellipsis + \"</a>\"\n          });\n          i.push(f);\n        }\n      }\n\n      i.push(c);\n      j = c;\n    });\n    return i;\n  };\n  /**\r\n   * Parse data to HTML table\r\n   */\n\n\n  var dataToTable = function dataToTable(data) {\n    var thead = false,\n        tbody = false;\n    data = data || this.options.data;\n\n    if (data.headings) {\n      thead = createElement(\"thead\");\n      var tr = createElement(\"tr\");\n      each(data.headings, function (col) {\n        var td = createElement(\"th\", {\n          html: col\n        });\n        tr.appendChild(td);\n      });\n      thead.appendChild(tr);\n    }\n\n    if (data.data && data.data.length) {\n      tbody = createElement(\"tbody\");\n      each(data.data, function (rows) {\n        if (data.headings) {\n          if (data.headings.length !== rows.length) {\n            throw new Error(\"The number of rows do not match the number of headings.\");\n          }\n        }\n\n        var tr = createElement(\"tr\");\n        each(rows, function (value) {\n          var td = createElement(\"td\", {\n            html: value\n          });\n          tr.appendChild(td);\n        });\n        tbody.appendChild(tr);\n      });\n    }\n\n    if (thead) {\n      if (this.table.tHead !== null) {\n        this.table.removeChild(this.table.tHead);\n      }\n\n      this.table.appendChild(thead);\n    }\n\n    if (tbody) {\n      if (this.table.tBodies.length) {\n        this.table.removeChild(this.table.tBodies[0]);\n      }\n\n      this.table.appendChild(tbody);\n    }\n  };\n  /**\r\n   * Use moment.js to parse cell contents for sorting\r\n   * @param  {String} content     The datetime string to parse\r\n   * @param  {String} format      The format for moment to use\r\n   * @return {String|Boolean}     Datatime string or false\r\n   */\n\n\n  var parseDate = function parseDate(content, format) {\n    var date = false; // moment() throws a fit if the string isn't a valid datetime string\n    // so we need to supply the format to the constructor (https://momentjs.com/docs/#/parsing/string-format/)\n    // Converting to YYYYMMDD ensures we can accurately sort the column numerically\n\n    if (format) {\n      switch (format) {\n        case \"ISO_8601\":\n          date = moment(content, moment.ISO_8601).format(\"YYYYMMDD\");\n          break;\n\n        case \"RFC_2822\":\n          date = moment(content, \"ddd, MM MMM YYYY HH:mm:ss ZZ\").format(\"YYYYMMDD\");\n          break;\n\n        case \"MYSQL\":\n          date = moment(content, \"YYYY-MM-DD hh:mm:ss\").format(\"YYYYMMDD\");\n          break;\n\n        case \"UNIX\":\n          date = moment(content).unix();\n          break;\n        // User defined format using the data-format attribute or columns[n].format option\n\n        default:\n          date = moment(content, format).format(\"YYYYMMDD\");\n          break;\n      }\n    }\n\n    return date;\n  };\n  /**\r\n   * Columns API\r\n   * @param {Object} instance DataTable instance\r\n   * @param {Mixed} columns  Column index or array of column indexes\r\n   */\n\n\n  var Columns = function Columns(dt) {\n    this.dt = dt;\n    return this;\n  };\n  /**\r\n   * Swap two columns\r\n   * @return {Void}\r\n   */\n\n\n  Columns.prototype.swap = function (columns) {\n    if (columns.length && columns.length === 2) {\n      var cols = []; // Get the current column indexes\n\n      each(this.dt.headings, function (h, i) {\n        cols.push(i);\n      });\n      var x = columns[0];\n      var y = columns[1];\n      var b = cols[y];\n      cols[y] = cols[x];\n      cols[x] = b;\n      this.order(cols);\n    }\n  };\n  /**\r\n   * Reorder the columns\r\n   * @return {Array} columns  Array of ordered column indexes\r\n   */\n\n\n  Columns.prototype.order = function (columns) {\n    var a,\n        b,\n        c,\n        d,\n        h,\n        s,\n        cell,\n        temp = [[], [], [], []],\n        dt = this.dt; // Order the headings\n\n    each(columns, function (column, x) {\n      h = dt.headings[column];\n      s = h.getAttribute(\"data-sortable\") !== \"false\";\n      a = h.cloneNode(true);\n      a.originalCellIndex = x;\n      a.sortable = s;\n      temp[0].push(a);\n\n      if (dt.hiddenColumns.indexOf(column) < 0) {\n        b = h.cloneNode(true);\n        b.originalCellIndex = x;\n        b.sortable = s;\n        temp[1].push(b);\n      }\n    }); // Order the row cells\n\n    each(dt.data, function (row, i) {\n      c = row.cloneNode();\n      d = row.cloneNode();\n      c.dataIndex = d.dataIndex = i;\n\n      if (row.searchIndex !== null && row.searchIndex !== undefined) {\n        c.searchIndex = d.searchIndex = row.searchIndex;\n      } // Append the cell to the fragment in the correct order\n\n\n      each(columns, function (column, x) {\n        cell = row.cells[column].cloneNode(true);\n        cell.data = row.cells[column].data;\n        c.appendChild(cell);\n\n        if (dt.hiddenColumns.indexOf(column) < 0) {\n          cell = row.cells[column].cloneNode(true);\n          cell.data = row.cells[column].data;\n          d.appendChild(cell);\n        }\n      });\n      temp[2].push(c);\n      temp[3].push(d);\n    });\n    dt.headings = temp[0];\n    dt.activeHeadings = temp[1];\n    dt.data = temp[2];\n    dt.activeRows = temp[3]; // Update\n\n    dt.update();\n  };\n  /**\r\n   * Hide columns\r\n   * @return {Void}\r\n   */\n\n\n  Columns.prototype.hide = function (columns) {\n    if (columns.length) {\n      var dt = this.dt;\n      each(columns, function (column) {\n        if (dt.hiddenColumns.indexOf(column) < 0) {\n          dt.hiddenColumns.push(column);\n        }\n      });\n      this.rebuild();\n    }\n  };\n  /**\r\n   * Show columns\r\n   * @return {Void}\r\n   */\n\n\n  Columns.prototype.show = function (columns) {\n    if (columns.length) {\n      var index,\n          dt = this.dt;\n      each(columns, function (column) {\n        index = dt.hiddenColumns.indexOf(column);\n\n        if (index > -1) {\n          dt.hiddenColumns.splice(index, 1);\n        }\n      });\n      this.rebuild();\n    }\n  };\n  /**\r\n   * Check column(s) visibility\r\n   * @return {Boolean}\r\n   */\n\n\n  Columns.prototype.visible = function (columns) {\n    var cols,\n        dt = this.dt;\n    columns = columns || dt.headings.map(function (th) {\n      return th.originalCellIndex;\n    });\n\n    if (!isNaN(columns)) {\n      cols = dt.hiddenColumns.indexOf(columns) < 0;\n    } else if (isArray(columns)) {\n      cols = [];\n      each(columns, function (column) {\n        cols.push(dt.hiddenColumns.indexOf(column) < 0);\n      });\n    }\n\n    return cols;\n  };\n  /**\r\n   * Add a new column\r\n   * @param {Object} data\r\n   */\n\n\n  Columns.prototype.add = function (data) {\n    var that = this,\n        td,\n        th = document.createElement(\"th\");\n\n    if (!this.dt.headings.length) {\n      this.dt.insert({\n        headings: [data.heading],\n        data: data.data.map(function (i) {\n          return [i];\n        })\n      });\n      this.rebuild();\n      return;\n    }\n\n    if (!this.dt.hiddenHeader) {\n      if (data.heading.nodeName) {\n        th.appendChild(data.heading);\n      } else {\n        th.innerHTML = data.heading;\n      }\n    } else {\n      th.innerHTML = \"\";\n    }\n\n    this.dt.headings.push(th);\n    each(this.dt.data, function (row, i) {\n      if (data.data[i]) {\n        td = document.createElement(\"td\");\n\n        if (data.data[i].nodeName) {\n          td.appendChild(data.data[i]);\n        } else {\n          td.innerHTML = data.data[i];\n        }\n\n        td.data = td.innerHTML;\n\n        if (data.render) {\n          td.innerHTML = data.render.call(that, td.data, td, row);\n        }\n\n        row.appendChild(td);\n      }\n    });\n\n    if (data.type) {\n      th.setAttribute(\"data-type\", data.type);\n    }\n\n    if (data.format) {\n      th.setAttribute(\"data-format\", data.format);\n    }\n\n    if (data.hasOwnProperty(\"sortable\")) {\n      th.sortable = data.sortable;\n      th.setAttribute(\"data-sortable\", data.sortable === true ? \"true\" : \"false\");\n    }\n\n    this.rebuild();\n    this.dt.renderHeader();\n  };\n  /**\r\n   * Remove column(s)\r\n   * @param  {Array|Number} select\r\n   * @return {Void}\r\n   */\n\n\n  Columns.prototype.remove = function (select) {\n    if (isArray(select)) {\n      // Remove in reverse otherwise the indexes will be incorrect\n      select.sort(function (a, b) {\n        return b - a;\n      });\n      each(select, function (column) {\n        this.remove(column);\n      }, this);\n    } else {\n      this.dt.headings.splice(select, 1);\n      each(this.dt.data, function (row) {\n        row.removeChild(row.cells[select]);\n      });\n    }\n\n    this.rebuild();\n  };\n  /**\r\n   * Sort by column\r\n   * @param  {int} column - The column no.\r\n   * @param  {string} direction - asc or desc\r\n   * @return {void}\r\n   */\n\n\n  Columns.prototype.sort = function (column, direction, init) {\n    var dt = this.dt; // Check column is present\n\n    if (dt.hasHeadings && (column < 1 || column > dt.activeHeadings.length)) {\n      return false;\n    }\n\n    dt.sorting = true; // Convert to zero-indexed\n\n    column = column - 1;\n    var dir,\n        rows = dt.data,\n        alpha = [],\n        numeric = [],\n        a = 0,\n        n = 0,\n        th = dt.activeHeadings[column];\n    column = th.originalCellIndex;\n    each(rows, function (tr) {\n      var cell = tr.cells[column];\n      var content = cell.hasAttribute('data-content') ? cell.getAttribute('data-content') : cell.data;\n      var num = content.replace(/(\\$|\\,|\\s|%)/g, \"\"); // Check for date format and moment.js\n\n      if (th.getAttribute(\"data-type\") === \"date\" && win.moment) {\n        var format = false,\n            formatted = th.hasAttribute(\"data-format\");\n\n        if (formatted) {\n          format = th.getAttribute(\"data-format\");\n        }\n\n        num = parseDate(content, format);\n      }\n\n      if (parseFloat(num) == num) {\n        numeric[n++] = {\n          value: Number(num),\n          row: tr\n        };\n      } else {\n        alpha[a++] = {\n          value: content,\n          row: tr\n        };\n      }\n    });\n    /* Sort according to direction (ascending or descending) */\n\n    var top, btm;\n\n    if (classList.contains(th, \"asc\") || direction == \"asc\") {\n      top = sortItems(alpha, -1);\n      btm = sortItems(numeric, -1);\n      dir = \"descending\";\n      classList.remove(th, \"asc\");\n      classList.add(th, \"desc\");\n    } else {\n      top = sortItems(numeric, 1);\n      btm = sortItems(alpha, 1);\n      dir = \"ascending\";\n      classList.remove(th, \"desc\");\n      classList.add(th, \"asc\");\n    }\n    /* Clear asc/desc class names from the last sorted column's th if it isn't the same as the one that was just clicked */\n\n\n    if (dt.lastTh && th != dt.lastTh) {\n      classList.remove(dt.lastTh, \"desc\");\n      classList.remove(dt.lastTh, \"asc\");\n    }\n\n    dt.lastTh = th;\n    /* Reorder the table */\n\n    rows = top.concat(btm);\n    dt.data = [];\n    var indexes = [];\n    each(rows, function (v, i) {\n      dt.data.push(v.row);\n\n      if (v.row.searchIndex !== null && v.row.searchIndex !== undefined) {\n        indexes.push(i);\n      }\n    }, dt);\n    dt.searchData = indexes;\n    this.rebuild();\n    dt.update();\n\n    if (!init) {\n      dt.emit(\"datatable.sort\", column, dir);\n    }\n  };\n  /**\r\n   * Rebuild the columns\r\n   * @return {Void}\r\n   */\n\n\n  Columns.prototype.rebuild = function () {\n    var a,\n        b,\n        c,\n        d,\n        dt = this.dt,\n        temp = [];\n    dt.activeRows = [];\n    dt.activeHeadings = [];\n    each(dt.headings, function (th, i) {\n      th.originalCellIndex = i;\n      th.sortable = th.getAttribute(\"data-sortable\") !== \"false\";\n\n      if (dt.hiddenColumns.indexOf(i) < 0) {\n        dt.activeHeadings.push(th);\n      }\n    }, this); // Loop over the rows and reorder the cells\n\n    each(dt.data, function (row, i) {\n      a = row.cloneNode();\n      b = row.cloneNode();\n      a.dataIndex = b.dataIndex = i;\n\n      if (row.searchIndex !== null && row.searchIndex !== undefined) {\n        a.searchIndex = b.searchIndex = row.searchIndex;\n      } // Append the cell to the fragment in the correct order\n\n\n      each(row.cells, function (cell) {\n        c = cell.cloneNode(true);\n        c.data = cell.data;\n        a.appendChild(c);\n\n        if (dt.hiddenColumns.indexOf(cell.cellIndex) < 0) {\n          d = cell.cloneNode(true);\n          d.data = cell.data;\n          b.appendChild(d);\n        }\n      }); // Append the fragment with the ordered cells\n\n      temp.push(a);\n      dt.activeRows.push(b);\n    });\n    dt.data = temp;\n    dt.update();\n  };\n  /**\r\n   * Rows API\r\n   * @param {Object} instance DataTable instance\r\n   * @param {Array} rows\r\n   */\n\n\n  var Rows = function Rows(dt, rows) {\n    this.dt = dt;\n    this.rows = rows;\n    return this;\n  };\n  /**\r\n   * Build a new row\r\n   * @param  {Array} row\r\n   * @return {HTMLElement}\r\n   */\n\n\n  Rows.prototype.build = function (row) {\n    var td,\n        tr = createElement(\"tr\");\n    var headings = this.dt.headings;\n\n    if (!headings.length) {\n      headings = row.map(function () {\n        return \"\";\n      });\n    }\n\n    each(headings, function (h, i) {\n      td = createElement(\"td\"); // Fixes #29\n\n      if (!row[i] && !row[i].length) {\n        row[i] = \"\";\n      }\n\n      td.innerHTML = row[i];\n      td.data = row[i];\n      tr.appendChild(td);\n    });\n    return tr;\n  };\n\n  Rows.prototype.render = function (row) {\n    return row;\n  };\n  /**\r\n   * Add new row\r\n   * @param {Array} select\r\n   */\n\n\n  Rows.prototype.add = function (data) {\n    if (isArray(data)) {\n      var dt = this.dt; // Check for multiple rows\n\n      if (isArray(data[0])) {\n        each(data, function (row, i) {\n          dt.data.push(this.build(row));\n        }, this);\n      } else {\n        dt.data.push(this.build(data));\n      } // We may have added data to an empty table\n\n\n      if (dt.data.length) {\n        dt.hasRows = true;\n      }\n\n      this.update();\n      dt.columns().rebuild();\n    }\n  };\n  /**\r\n   * Remove row(s)\r\n   * @param  {Array|Number} select\r\n   * @return {Void}\r\n   */\n\n\n  Rows.prototype.remove = function (select) {\n    var dt = this.dt;\n\n    if (isArray(select)) {\n      // Remove in reverse otherwise the indexes will be incorrect\n      select.sort(function (a, b) {\n        return b - a;\n      });\n      each(select, function (row, i) {\n        dt.data.splice(row, 1);\n      });\n    } else {\n      dt.data.splice(select, 1);\n    }\n\n    this.update();\n    dt.columns().rebuild();\n  };\n  /**\r\n   * Update row indexes\r\n   * @return {Void}\r\n   */\n\n\n  Rows.prototype.update = function () {\n    each(this.dt.data, function (row, i) {\n      row.dataIndex = i;\n    });\n  }; ////////////////////\n  //    MAIN LIB    //\n  ////////////////////\n\n\n  var DataTable = function DataTable(table, options) {\n    this.initialized = false; // user options\n\n    this.options = extend(defaultConfig, options);\n\n    if (typeof table === \"string\") {\n      table = document.querySelector(table);\n    }\n\n    this.initialLayout = table.innerHTML;\n    this.initialSortable = this.options.sortable; // Disable manual sorting if no header is present (#4)\n\n    if (!this.options.header) {\n      this.options.sortable = false;\n    }\n\n    if (table.tHead === null) {\n      if (!this.options.data || this.options.data && !this.options.data.headings) {\n        this.options.sortable = false;\n      }\n    }\n\n    if (table.tBodies.length && !table.tBodies[0].rows.length) {\n      if (this.options.data) {\n        if (!this.options.data.data) {\n          throw new Error(\"You seem to be using the data option, but you've not defined any rows.\");\n        }\n      }\n    }\n\n    this.table = table;\n    this.init();\n  };\n  /**\r\n   * Add custom property or method to extend DataTable\r\n   * @param  {String} prop    - Method name or property\r\n   * @param  {Mixed} val      - Function or property value\r\n   * @return {Void}\r\n   */\n\n\n  DataTable.extend = function (prop, val) {\n    if (typeof val === \"function\") {\n      DataTable.prototype[prop] = val;\n    } else {\n      DataTable[prop] = val;\n    }\n  };\n\n  var proto = DataTable.prototype;\n  /**\r\n   * Initialize the instance\r\n   * @param  {Object} options\r\n   * @return {Void}\r\n   */\n\n  proto.init = function (options) {\n    if (this.initialized || classList.contains(this.table, \"dataTable-table\")) {\n      return false;\n    }\n\n    var that = this;\n    this.options = extend(this.options, options || {}); // IE detection\n\n    this.isIE = !!/(msie|trident)/i.test(navigator.userAgent);\n    this.currentPage = 1;\n    this.onFirstPage = true;\n    this.hiddenColumns = [];\n    this.columnRenderers = [];\n    this.selectedColumns = [];\n    this.render();\n    setTimeout(function () {\n      that.emit(\"datatable.init\");\n      that.initialized = true;\n\n      if (that.options.plugins) {\n        each(that.options.plugins, function (options, plugin) {\n          if (that[plugin] && typeof that[plugin] === \"function\") {\n            that[plugin] = that[plugin](options, {\n              each: each,\n              extend: extend,\n              classList: classList,\n              createElement: createElement\n            }); // Init plugin\n\n            if (options.enabled && that[plugin].init && typeof that[plugin].init === \"function\") {\n              that[plugin].init();\n            }\n          }\n        });\n      }\n    }, 10);\n  };\n  /**\r\n   * Render the instance\r\n   * @param  {String} type\r\n   * @return {Void}\r\n   */\n\n\n  proto.render = function (type) {\n    if (type) {\n      switch (type) {\n        case \"page\":\n          this.renderPage();\n          break;\n\n        case \"pager\":\n          this.renderPager();\n          break;\n\n        case \"header\":\n          this.renderHeader();\n          break;\n      }\n\n      return false;\n    }\n\n    var that = this,\n        o = that.options,\n        template = \"\"; // Convert data to HTML\n\n    if (o.data) {\n      dataToTable.call(that);\n    }\n\n    if (o.ajax) {\n      var ajax = o.ajax;\n      var xhr = new XMLHttpRequest();\n\n      var xhrProgress = function xhrProgress(e) {\n        that.emit(\"datatable.ajax.progress\", e, xhr);\n      };\n\n      var xhrLoad = function xhrLoad(e) {\n        if (xhr.readyState === 4) {\n          that.emit(\"datatable.ajax.loaded\", e, xhr);\n\n          if (xhr.status === 200) {\n            var obj = {};\n            obj.data = ajax.load ? ajax.load.call(that, xhr) : xhr.responseText;\n            obj.type = \"json\";\n\n            if (ajax.content && ajax.content.type) {\n              obj.type = ajax.content.type;\n              obj = extend(obj, ajax.content);\n            }\n\n            that.import(obj);\n            that.setColumns(true);\n            that.emit(\"datatable.ajax.success\", e, xhr);\n          } else {\n            that.emit(\"datatable.ajax.error\", e, xhr);\n          }\n        }\n      };\n\n      var xhrFailed = function xhrFailed(e) {\n        that.emit(\"datatable.ajax.error\", e, xhr);\n      };\n\n      var xhrCancelled = function xhrCancelled(e) {\n        that.emit(\"datatable.ajax.abort\", e, xhr);\n      };\n\n      on(xhr, \"progress\", xhrProgress);\n      on(xhr, \"load\", xhrLoad);\n      on(xhr, \"error\", xhrFailed);\n      on(xhr, \"abort\", xhrCancelled);\n      that.emit(\"datatable.ajax.loading\", xhr);\n      xhr.open(\"GET\", typeof ajax === \"string\" ? o.ajax : o.ajax.url);\n      xhr.send();\n    } // Store references\n\n\n    that.body = that.table.tBodies[0];\n    that.head = that.table.tHead;\n    that.foot = that.table.tFoot;\n\n    if (!that.body) {\n      that.body = createElement(\"tbody\");\n      that.table.appendChild(that.body);\n    }\n\n    that.hasRows = that.body.rows.length > 0; // Make a tHead if there isn't one (fixes #8)\n\n    if (!that.head) {\n      var h = createElement(\"thead\");\n      var t = createElement(\"tr\");\n\n      if (that.hasRows) {\n        each(that.body.rows[0].cells, function () {\n          t.appendChild(createElement(\"th\"));\n        });\n        h.appendChild(t);\n      }\n\n      that.head = h;\n      that.table.insertBefore(that.head, that.body);\n      that.hiddenHeader = !o.ajax;\n    }\n\n    that.headings = [];\n    that.hasHeadings = that.head.rows.length > 0;\n\n    if (that.hasHeadings) {\n      that.header = that.head.rows[0];\n      that.headings = [].slice.call(that.header.cells);\n    } // Header\n\n\n    if (!o.header) {\n      if (that.head) {\n        that.table.removeChild(that.table.tHead);\n      }\n    } // Footer\n\n\n    if (o.footer) {\n      if (that.head && !that.foot) {\n        that.foot = createElement(\"tfoot\", {\n          html: that.head.innerHTML\n        });\n        that.table.appendChild(that.foot);\n      }\n    } else {\n      if (that.foot) {\n        that.table.removeChild(that.table.tFoot);\n      }\n    } // Build\n\n\n    that.wrapper = createElement(\"div\", {\n      class: \"dataTable-wrapper dataTable-loading\"\n    }); // Template for custom layouts\n\n    template += \"<div class='dataTable-top'>\";\n    template += o.layout.top;\n    template += \"</div>\";\n    template += \"<div class='dataTable-container'></div>\";\n    template += \"<div class='dataTable-bottom'>\";\n    template += o.layout.bottom;\n    template += \"</div>\"; // Info placement\n\n    template = template.replace(\"{info}\", \"<div class='dataTable-info'></div>\"); // Per Page Select\n\n    if (o.perPageSelect) {\n      var wrap = \"<div class='dataTable-dropdown'><label>\";\n      wrap += o.labels.perPage;\n      wrap += \"</label></div>\"; // Create the select\n\n      var select = createElement(\"select\", {\n        class: \"dataTable-selector\"\n      }); // Create the options\n\n      each(o.perPageSelect, function (val) {\n        var selected = val === o.perPage;\n        var option = new Option(val, val, selected, selected);\n        select.add(option);\n      }); // Custom label\n\n      wrap = wrap.replace(\"{select}\", select.outerHTML); // Selector placement\n\n      template = template.replace(\"{select}\", wrap);\n    } else {\n      template = template.replace(\"{select}\", \"\");\n    } // Searchable\n\n\n    if (o.searchable) {\n      var form = \"<div class='dataTable-search'><input class='dataTable-input' placeholder='\" + o.labels.placeholder + \"' type='text'></div>\"; // Search input placement\n\n      template = template.replace(\"{search}\", form);\n    } else {\n      template = template.replace(\"{search}\", \"\");\n    }\n\n    if (that.hasHeadings) {\n      // Sortable\n      this.render(\"header\");\n    } // Add table class\n\n\n    classList.add(that.table, \"dataTable-table\"); // Paginator\n\n    var w = createElement(\"div\", {\n      class: \"dataTable-pagination\"\n    });\n    var paginator = createElement(\"ul\");\n    w.appendChild(paginator); // Pager(s) placement\n\n    template = template.replace(/\\{pager\\}/g, w.outerHTML);\n    that.wrapper.innerHTML = template;\n    that.container = that.wrapper.querySelector(\".dataTable-container\");\n    that.pagers = that.wrapper.querySelectorAll(\".dataTable-pagination\");\n    that.label = that.wrapper.querySelector(\".dataTable-info\"); // Insert in to DOM tree\n\n    that.table.parentNode.replaceChild(that.wrapper, that.table);\n    that.container.appendChild(that.table); // Store the table dimensions\n\n    that.rect = that.table.getBoundingClientRect(); // Convert rows to array for processing\n\n    that.data = [].slice.call(that.body.rows);\n    that.activeRows = that.data.slice();\n    that.activeHeadings = that.headings.slice(); // Update\n\n    that.update();\n\n    if (!o.ajax) {\n      that.setColumns();\n    } // Fix height\n\n\n    this.fixHeight(); // Fix columns\n\n    that.fixColumns(); // Class names\n\n    if (!o.header) {\n      classList.add(that.wrapper, \"no-header\");\n    }\n\n    if (!o.footer) {\n      classList.add(that.wrapper, \"no-footer\");\n    }\n\n    if (o.sortable) {\n      classList.add(that.wrapper, \"sortable\");\n    }\n\n    if (o.searchable) {\n      classList.add(that.wrapper, \"searchable\");\n    }\n\n    if (o.fixedHeight) {\n      classList.add(that.wrapper, \"fixed-height\");\n    }\n\n    if (o.fixedColumns) {\n      classList.add(that.wrapper, \"fixed-columns\");\n    }\n\n    that.bindEvents();\n  };\n  /**\r\n   * Render the page\r\n   * @return {Void}\r\n   */\n\n\n  proto.renderPage = function () {\n    if (this.hasRows && this.totalPages) {\n      if (this.currentPage > this.totalPages) {\n        this.currentPage = 1;\n      } // Use a fragment to limit touching the DOM\n\n\n      var index = this.currentPage - 1,\n          frag = doc.createDocumentFragment();\n\n      if (this.hasHeadings) {\n        flush(this.header, this.isIE);\n        each(this.activeHeadings, function (th) {\n          this.header.appendChild(th);\n        }, this);\n      }\n\n      each(this.pages[index], function (row) {\n        frag.appendChild(this.rows().render(row));\n      }, this);\n      this.clear(frag);\n      this.onFirstPage = this.currentPage === 1;\n      this.onLastPage = this.currentPage === this.lastPage;\n    } else {\n      this.clear();\n    } // Update the info\n\n\n    var current = 0,\n        f = 0,\n        t = 0,\n        items;\n\n    if (this.totalPages) {\n      current = this.currentPage - 1;\n      f = current * this.options.perPage;\n      t = f + this.pages[current].length;\n      f = f + 1;\n      items = !!this.searching ? this.searchData.length : this.data.length;\n    }\n\n    if (this.label && this.options.labels.info.length) {\n      // CUSTOM LABELS\n      var string = this.options.labels.info.replace(\"{start}\", f).replace(\"{end}\", t).replace(\"{page}\", this.currentPage).replace(\"{pages}\", this.totalPages).replace(\"{rows}\", items);\n      this.label.innerHTML = items ? string : \"\";\n    }\n\n    if (this.currentPage == 1) {\n      this.fixHeight();\n    }\n  };\n  /**\r\n   * Render the pager(s)\r\n   * @return {Void}\r\n   */\n\n\n  proto.renderPager = function () {\n    flush(this.pagers, this.isIE);\n\n    if (this.totalPages > 1) {\n      var c = \"pager\",\n          frag = doc.createDocumentFragment(),\n          prev = this.onFirstPage ? 1 : this.currentPage - 1,\n          next = this.onlastPage ? this.totalPages : this.currentPage + 1; // first button\n\n      if (this.options.firstLast) {\n        frag.appendChild(button(c, 1, this.options.firstText));\n      } // prev button\n\n\n      if (this.options.nextPrev) {\n        frag.appendChild(button(c, prev, this.options.prevText));\n      }\n\n      var pager = this.links; // truncate the links\n\n      if (this.options.truncatePager) {\n        pager = truncate(this.links, this.currentPage, this.pages.length, this.options.pagerDelta, this.options.ellipsisText);\n      } // active page link\n\n\n      classList.add(this.links[this.currentPage - 1], \"active\"); // append the links\n\n      each(pager, function (p) {\n        classList.remove(p, \"active\");\n        frag.appendChild(p);\n      });\n      classList.add(this.links[this.currentPage - 1], \"active\"); // next button\n\n      if (this.options.nextPrev) {\n        frag.appendChild(button(c, next, this.options.nextText));\n      } // first button\n\n\n      if (this.options.firstLast) {\n        frag.appendChild(button(c, this.totalPages, this.options.lastText));\n      } // We may have more than one pager\n\n\n      each(this.pagers, function (pager) {\n        pager.appendChild(frag.cloneNode(true));\n      });\n    }\n  };\n  /**\r\n   * Render the header\r\n   * @return {Void}\r\n   */\n\n\n  proto.renderHeader = function () {\n    var that = this;\n    that.labels = [];\n\n    if (that.headings && that.headings.length) {\n      each(that.headings, function (th, i) {\n        that.labels[i] = th.textContent;\n\n        if (classList.contains(th.firstElementChild, \"dataTable-sorter\")) {\n          th.innerHTML = th.firstElementChild.innerHTML;\n        }\n\n        th.sortable = th.getAttribute(\"data-sortable\") !== \"false\";\n        th.originalCellIndex = i;\n\n        if (that.options.sortable && th.sortable) {\n          var link = createElement(\"a\", {\n            href: \"#\",\n            class: \"dataTable-sorter\",\n            html: th.innerHTML\n          });\n          th.innerHTML = \"\";\n          th.setAttribute(\"data-sortable\", \"\");\n          th.appendChild(link);\n        }\n      });\n    }\n\n    that.fixColumns();\n  };\n  /**\r\n   * Bind event listeners\r\n   * @return {[type]} [description]\r\n   */\n\n\n  proto.bindEvents = function () {\n    var that = this,\n        o = that.options; // Per page selector\n\n    if (o.perPageSelect) {\n      var selector = that.wrapper.querySelector(\".dataTable-selector\");\n\n      if (selector) {\n        // Change per page\n        on(selector, \"change\", function (e) {\n          o.perPage = parseInt(this.value, 10);\n          that.update();\n          that.fixHeight();\n          that.emit(\"datatable.perpage\", o.perPage);\n        });\n      }\n    } // Search input\n\n\n    if (o.searchable) {\n      that.input = that.wrapper.querySelector(\".dataTable-input\");\n\n      if (that.input) {\n        on(that.input, \"keyup\", function (e) {\n          that.search(this.value);\n        });\n      }\n    } // Pager(s) / sorting\n\n\n    on(that.wrapper, \"click\", function (e) {\n      var t = e.target;\n\n      if (t.nodeName.toLowerCase() === \"a\") {\n        if (t.hasAttribute(\"data-page\")) {\n          that.page(t.getAttribute(\"data-page\"));\n          e.preventDefault();\n        } else if (o.sortable && classList.contains(t, \"dataTable-sorter\") && t.parentNode.getAttribute(\"data-sortable\") != \"false\") {\n          that.columns().sort(that.activeHeadings.indexOf(t.parentNode) + 1);\n          e.preventDefault();\n        }\n      }\n    });\n  };\n  /**\r\n   * Set up columns\r\n   * @return {[type]} [description]\r\n   */\n\n\n  proto.setColumns = function (ajax) {\n    var that = this;\n\n    if (!ajax) {\n      each(that.data, function (row) {\n        each(row.cells, function (cell) {\n          cell.data = cell.innerHTML;\n        });\n      });\n    } // Check for the columns option\n\n\n    if (that.options.columns && that.headings.length) {\n      each(that.options.columns, function (data) {\n        // convert single column selection to array\n        if (!isArray(data.select)) {\n          data.select = [data.select];\n        }\n\n        if (data.hasOwnProperty(\"render\") && typeof data.render === \"function\") {\n          that.selectedColumns = that.selectedColumns.concat(data.select);\n          that.columnRenderers.push({\n            columns: data.select,\n            renderer: data.render\n          });\n        } // Add the data attributes to the th elements\n\n\n        each(data.select, function (column) {\n          var th = that.headings[column];\n\n          if (data.type) {\n            th.setAttribute(\"data-type\", data.type);\n          }\n\n          if (data.format) {\n            th.setAttribute(\"data-format\", data.format);\n          }\n\n          if (data.hasOwnProperty(\"sortable\")) {\n            th.setAttribute(\"data-sortable\", data.sortable);\n          }\n\n          if (data.hasOwnProperty(\"hidden\")) {\n            if (data.hidden !== false) {\n              that.columns().hide(column);\n            }\n          }\n\n          if (data.hasOwnProperty(\"sort\") && data.select.length === 1) {\n            that.columns().sort(data.select[0] + 1, data.sort, true);\n          }\n        });\n      });\n    }\n\n    if (that.hasRows) {\n      each(that.data, function (row, i) {\n        row.dataIndex = i;\n        each(row.cells, function (cell) {\n          cell.data = cell.innerHTML;\n        });\n      });\n\n      if (that.selectedColumns.length) {\n        each(that.data, function (row) {\n          each(row.cells, function (cell, i) {\n            if (that.selectedColumns.indexOf(i) > -1) {\n              each(that.columnRenderers, function (o) {\n                if (o.columns.indexOf(i) > -1) {\n                  cell.innerHTML = o.renderer.call(that, cell.data, cell, row);\n                }\n              });\n            }\n          });\n        });\n      }\n\n      that.columns().rebuild();\n    }\n\n    that.render(\"header\");\n  };\n  /**\r\n   * Destroy the instance\r\n   * @return {void}\r\n   */\n\n\n  proto.destroy = function () {\n    this.table.innerHTML = this.initialLayout; // Remove the className\n\n    classList.remove(this.table, \"dataTable-table\"); // Remove the containers\n\n    this.wrapper.parentNode.replaceChild(this.table, this.wrapper);\n    this.initialized = false;\n  };\n  /**\r\n   * Update the instance\r\n   * @return {Void}\r\n   */\n\n\n  proto.update = function () {\n    classList.remove(this.wrapper, \"dataTable-empty\");\n    this.paginate(this);\n    this.render(\"page\");\n    this.links = [];\n    var i = this.pages.length;\n\n    while (i--) {\n      var num = i + 1;\n      this.links[i] = button(i === 0 ? \"active\" : \"\", num, num);\n    }\n\n    this.sorting = false;\n    this.render(\"pager\");\n    this.rows().update();\n    this.emit(\"datatable.update\");\n  };\n  /**\r\n   * Sort rows into pages\r\n   * @return {Number}\r\n   */\n\n\n  proto.paginate = function () {\n    var perPage = this.options.perPage,\n        rows = this.activeRows;\n\n    if (this.searching) {\n      rows = [];\n      each(this.searchData, function (index) {\n        rows.push(this.activeRows[index]);\n      }, this);\n    } // Check for hidden columns\n\n\n    this.pages = rows.map(function (tr, i) {\n      return i % perPage === 0 ? rows.slice(i, i + perPage) : null;\n    }).filter(function (page) {\n      return page;\n    });\n    this.totalPages = this.lastPage = this.pages.length;\n    return this.totalPages;\n  };\n  /**\r\n   * Fix column widths\r\n   * @return {Void}\r\n   */\n\n\n  proto.fixColumns = function () {\n    if (this.options.fixedColumns && this.activeHeadings && this.activeHeadings.length) {\n      var cells,\n          hd = false;\n      this.columnWidths = []; // If we have headings we need only set the widths on them\n      // otherwise we need a temp header and the widths need applying to all cells\n\n      if (this.table.tHead) {\n        // Reset widths\n        each(this.activeHeadings, function (cell) {\n          cell.style.width = \"\";\n        }, this);\n        each(this.activeHeadings, function (cell, i) {\n          var ow = cell.offsetWidth;\n          var w = ow / this.rect.width * 100;\n          cell.style.width = w + \"%\";\n          this.columnWidths[i] = ow;\n        }, this);\n      } else {\n        cells = []; // Make temperary headings\n\n        hd = createElement(\"thead\");\n        var r = createElement(\"tr\");\n        var c = this.table.tBodies[0].rows[0].cells;\n        each(c, function () {\n          var th = createElement(\"th\");\n          r.appendChild(th);\n          cells.push(th);\n        });\n        hd.appendChild(r);\n        this.table.insertBefore(hd, this.body);\n        var widths = [];\n        each(cells, function (cell, i) {\n          var ow = cell.offsetWidth;\n          var w = ow / this.rect.width * 100;\n          widths.push(w);\n          this.columnWidths[i] = ow;\n        }, this);\n        each(this.data, function (row) {\n          each(row.cells, function (cell, i) {\n            if (this.columns(cell.cellIndex).visible()) cell.style.width = widths[i] + \"%\";\n          }, this);\n        }, this); // Discard the temp header\n\n        this.table.removeChild(hd);\n      }\n    }\n  };\n  /**\r\n   * Fix the container height;\r\n   * @return {Void}\r\n   */\n\n\n  proto.fixHeight = function () {\n    if (this.options.fixedHeight) {\n      this.container.style.height = null;\n      this.rect = this.container.getBoundingClientRect();\n      this.container.style.height = this.rect.height + \"px\";\n    }\n  };\n  /**\r\n   * Perform a search of the data set\r\n   * @param  {string} query\r\n   * @return {void}\r\n   */\n\n\n  proto.search = function (query) {\n    if (!this.hasRows) return false;\n    var that = this;\n    query = query.toLowerCase();\n    this.currentPage = 1;\n    this.searching = true;\n    this.searchData = [];\n\n    if (!query.length) {\n      this.searching = false;\n      this.update();\n      this.emit(\"datatable.search\", query, this.searchData);\n      classList.remove(this.wrapper, \"search-results\");\n      return false;\n    }\n\n    this.clear();\n    each(this.data, function (row, idx) {\n      var inArray = this.searchData.indexOf(row) > -1; // https://github.com/Mobius1/Vanilla-DataTables/issues/12\n\n      var doesQueryMatch = query.split(\" \").reduce(function (bool, word) {\n        var includes = false,\n            cell = null,\n            content = null;\n\n        for (var x = 0; x < row.cells.length; x++) {\n          cell = row.cells[x];\n          content = cell.hasAttribute('data-content') ? cell.getAttribute('data-content') : cell.textContent;\n\n          if (content.toLowerCase().indexOf(word) > -1 && that.columns(cell.cellIndex).visible()) {\n            includes = true;\n            break;\n          }\n        }\n\n        return bool && includes;\n      }, true);\n\n      if (doesQueryMatch && !inArray) {\n        row.searchIndex = idx;\n        this.searchData.push(idx);\n      } else {\n        row.searchIndex = null;\n      }\n    }, this);\n    classList.add(this.wrapper, \"search-results\");\n\n    if (!that.searchData.length) {\n      classList.remove(that.wrapper, \"search-results\");\n      that.setMessage(that.options.labels.noRows);\n    } else {\n      that.update();\n    }\n\n    this.emit(\"datatable.search\", query, this.searchData);\n  };\n  /**\r\n   * Change page\r\n   * @param  {int} page\r\n   * @return {void}\r\n   */\n\n\n  proto.page = function (page) {\n    // We don't want to load the current page again.\n    if (page == this.currentPage) {\n      return false;\n    }\n\n    if (!isNaN(page)) {\n      this.currentPage = parseInt(page, 10);\n    }\n\n    if (page > this.pages.length || page < 0) {\n      return false;\n    }\n\n    this.render(\"page\");\n    this.render(\"pager\");\n    this.emit(\"datatable.page\", page);\n  };\n  /**\r\n   * Sort by column\r\n   * @param  {int} column - The column no.\r\n   * @param  {string} direction - asc or desc\r\n   * @return {void}\r\n   */\n\n\n  proto.sortColumn = function (column, direction) {\n    // Use columns API until sortColumn method is removed\n    this.columns().sort(column, direction);\n  };\n  /**\r\n   * Add new row data\r\n   * @param {object} data\r\n   */\n\n\n  proto.insert = function (data) {\n    var that = this,\n        rows = [];\n\n    if (isObject(data)) {\n      if (data.headings) {\n        if (!that.hasHeadings && !that.hasRows) {\n          var tr = createElement(\"tr\"),\n              th;\n          each(data.headings, function (heading) {\n            th = createElement(\"th\", {\n              html: heading\n            });\n            tr.appendChild(th);\n          });\n          that.head.appendChild(tr);\n          that.header = tr;\n          that.headings = [].slice.call(tr.cells);\n          that.hasHeadings = true; // Re-enable sorting if it was disabled due\n          // to missing header\n\n          that.options.sortable = that.initialSortable; // Allow sorting on new header\n\n          that.render(\"header\");\n        }\n      }\n\n      if (data.data && isArray(data.data)) {\n        rows = data.data;\n      }\n    } else if (isArray(data)) {\n      each(data, function (row) {\n        var r = [];\n        each(row, function (cell, heading) {\n          var index = that.labels.indexOf(heading);\n\n          if (index > -1) {\n            r[index] = cell;\n          }\n        });\n        rows.push(r);\n      });\n    }\n\n    if (rows.length) {\n      that.rows().add(rows);\n      that.hasRows = true;\n    }\n\n    that.update();\n    that.fixColumns();\n  };\n  /**\r\n   * Refresh the instance\r\n   * @return {void}\r\n   */\n\n\n  proto.refresh = function () {\n    if (this.options.searchable) {\n      this.input.value = \"\";\n      this.searching = false;\n    }\n\n    this.currentPage = 1;\n    this.onFirstPage = true;\n    this.update();\n    this.emit(\"datatable.refresh\");\n  };\n  /**\r\n   * Truncate the table\r\n   * @param  {mixes} html - HTML string or HTMLElement\r\n   * @return {void}\r\n   */\n\n\n  proto.clear = function (html) {\n    if (this.body) {\n      flush(this.body, this.isIE);\n    }\n\n    var parent = this.body;\n\n    if (!this.body) {\n      parent = this.table;\n    }\n\n    if (html) {\n      if (typeof html === \"string\") {\n        var frag = doc.createDocumentFragment();\n        frag.innerHTML = html;\n      }\n\n      parent.appendChild(html);\n    }\n  };\n  /**\r\n   * Export table to various formats (csv, txt or sql)\r\n   * @param  {Object} options User options\r\n   * @return {Boolean}\r\n   */\n\n\n  proto.export = function (options) {\n    if (!this.hasHeadings && !this.hasRows) return false;\n    var headers = this.activeHeadings,\n        rows = [],\n        arr = [],\n        i,\n        x,\n        str,\n        link;\n    var defaults = {\n      download: true,\n      skipColumn: [],\n      // csv\n      lineDelimiter: \"\\n\",\n      columnDelimiter: \",\",\n      // sql\n      tableName: \"myTable\",\n      // json\n      replacer: null,\n      space: 4\n    }; // Check for the options object\n\n    if (!isObject(options)) {\n      return false;\n    }\n\n    var o = extend(defaults, options);\n\n    if (o.type) {\n      if (o.type === \"txt\" || o.type === \"csv\") {\n        // Include headings\n        rows[0] = this.header;\n      } // Selection or whole table\n\n\n      if (o.selection) {\n        // Page number\n        if (!isNaN(o.selection)) {\n          rows = rows.concat(this.pages[o.selection - 1]);\n        } else if (isArray(o.selection)) {\n          // Array of page numbers\n          for (i = 0; i < o.selection.length; i++) {\n            rows = rows.concat(this.pages[o.selection[i] - 1]);\n          }\n        }\n      } else {\n        rows = rows.concat(this.activeRows);\n      } // Only proceed if we have data\n\n\n      if (rows.length) {\n        if (o.type === \"txt\" || o.type === \"csv\") {\n          str = \"\";\n\n          for (i = 0; i < rows.length; i++) {\n            for (x = 0; x < rows[i].cells.length; x++) {\n              // Check for column skip and visibility\n              if (o.skipColumn.indexOf(headers[x].originalCellIndex) < 0 && this.columns(headers[x].originalCellIndex).visible()) {\n                var text = rows[i].cells[x].textContent;\n                text = text.trim();\n                text = text.replace(/\\s{2,}/g, ' ');\n                text = text.replace(/\\n/g, '  ');\n                text = text.replace(/\"/g, '\"\"');\n                if (text.indexOf(\",\") > -1) text = '\"' + text + '\"';\n                str += text + o.columnDelimiter;\n              }\n            } // Remove trailing column delimiter\n\n\n            str = str.trim().substring(0, str.length - 1); // Apply line delimiter\n\n            str += o.lineDelimiter;\n          } // Remove trailing line delimiter\n\n\n          str = str.trim().substring(0, str.length - 1);\n\n          if (o.download) {\n            str = \"data:text/csv;charset=utf-8,\" + str;\n          }\n        } else if (o.type === \"sql\") {\n          // Begin INSERT statement\n          str = \"INSERT INTO `\" + o.tableName + \"` (\"; // Convert table headings to column names\n\n          for (i = 0; i < headers.length; i++) {\n            // Check for column skip and column visibility\n            if (o.skipColumn.indexOf(headers[i].originalCellIndex) < 0 && this.columns(headers[i].originalCellIndex).visible()) {\n              str += \"`\" + headers[i].textContent + \"`,\";\n            }\n          } // Remove trailing comma\n\n\n          str = str.trim().substring(0, str.length - 1); // Begin VALUES\n\n          str += \") VALUES \"; // Iterate rows and convert cell data to column values\n\n          for (i = 0; i < rows.length; i++) {\n            str += \"(\";\n\n            for (x = 0; x < rows[i].cells.length; x++) {\n              // Check for column skip and column visibility\n              if (o.skipColumn.indexOf(headers[x].originalCellIndex) < 0 && this.columns(headers[x].originalCellIndex).visible()) {\n                str += '\"' + rows[i].cells[x].textContent + '\",';\n              }\n            } // Remove trailing comma\n\n\n            str = str.trim().substring(0, str.length - 1); // end VALUES\n\n            str += \"),\";\n          } // Remove trailing comma\n\n\n          str = str.trim().substring(0, str.length - 1); // Add trailing colon\n\n          str += \";\";\n\n          if (o.download) {\n            str = \"data:application/sql;charset=utf-8,\" + str;\n          }\n        } else if (o.type === \"json\") {\n          // Iterate rows\n          for (x = 0; x < rows.length; x++) {\n            arr[x] = arr[x] || {}; // Iterate columns\n\n            for (i = 0; i < headers.length; i++) {\n              // Check for column skip and column visibility\n              if (o.skipColumn.indexOf(headers[i].originalCellIndex) < 0 && this.columns(headers[i].originalCellIndex).visible()) {\n                arr[x][headers[i].textContent] = rows[x].cells[i].textContent;\n              }\n            }\n          } // Convert the array of objects to JSON string\n\n\n          str = JSON.stringify(arr, o.replacer, o.space);\n\n          if (o.download) {\n            str = \"data:application/json;charset=utf-8,\" + str;\n          }\n        } // Download\n\n\n        if (o.download) {\n          // Filename\n          o.filename = o.filename || \"datatable_export\";\n          o.filename += \".\" + o.type;\n          str = encodeURI(str); // Create a link to trigger the download\n\n          link = document.createElement(\"a\");\n          link.href = str;\n          link.download = o.filename; // Append the link\n\n          body.appendChild(link); // Trigger the download\n\n          link.click(); // Remove the link\n\n          body.removeChild(link);\n        }\n\n        return str;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Import data to the table\r\n   * @param  {Object} options User options\r\n   * @return {Boolean}\r\n   */\n\n\n  proto.import = function (options) {\n    var obj = false;\n    var defaults = {\n      // csv\n      lineDelimiter: \"\\n\",\n      columnDelimiter: \",\"\n    }; // Check for the options object\n\n    if (!isObject(options)) {\n      return false;\n    }\n\n    options = extend(defaults, options);\n\n    if (options.data.length || isObject(options.data)) {\n      // Import CSV\n      if (options.type === \"csv\") {\n        obj = {\n          data: []\n        }; // Split the string into rows\n\n        var rows = options.data.split(options.lineDelimiter);\n\n        if (rows.length) {\n          if (options.headings) {\n            obj.headings = rows[0].split(options.columnDelimiter);\n            rows.shift();\n          }\n\n          each(rows, function (row, i) {\n            obj.data[i] = []; // Split the rows into values\n\n            var values = row.split(options.columnDelimiter);\n\n            if (values.length) {\n              each(values, function (value) {\n                obj.data[i].push(value);\n              });\n            }\n          });\n        }\n      } else if (options.type === \"json\") {\n        var json = isJson(options.data); // Valid JSON string\n\n        if (json) {\n          obj = {\n            headings: [],\n            data: []\n          };\n          each(json, function (data, i) {\n            obj.data[i] = [];\n            each(data, function (value, column) {\n              if (obj.headings.indexOf(column) < 0) {\n                obj.headings.push(column);\n              }\n\n              obj.data[i].push(value);\n            });\n          });\n        } else {\n          console.warn(\"That's not valid JSON!\");\n        }\n      }\n\n      if (isObject(options.data)) {\n        obj = options.data;\n      }\n\n      if (obj) {\n        // Add the rows\n        this.insert(obj);\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Print the table\r\n   * @return {void}\r\n   */\n\n\n  proto.print = function () {\n    var headings = this.activeHeadings;\n    var rows = this.activeRows;\n    var table = createElement(\"table\");\n    var thead = createElement(\"thead\");\n    var tbody = createElement(\"tbody\");\n    var tr = createElement(\"tr\");\n    each(headings, function (th) {\n      tr.appendChild(createElement(\"th\", {\n        html: th.textContent\n      }));\n    });\n    thead.appendChild(tr);\n    each(rows, function (row) {\n      var tr = createElement(\"tr\");\n      each(row.cells, function (cell) {\n        tr.appendChild(createElement(\"td\", {\n          html: cell.textContent\n        }));\n      });\n      tbody.appendChild(tr);\n    });\n    table.appendChild(thead);\n    table.appendChild(tbody); // Open new window\n\n    var w = win.open(); // Append the table to the body\n\n    w.document.body.appendChild(table); // Print\n\n    w.print();\n  };\n  /**\r\n   * Show a message in the table\r\n   * @param {string} message\r\n   */\n\n\n  proto.setMessage = function (message) {\n    var colspan = 1;\n\n    if (this.hasRows) {\n      colspan = this.data[0].cells.length;\n    }\n\n    classList.add(this.wrapper, \"dataTable-empty\");\n    this.clear(createElement(\"tr\", {\n      html: '<td class=\"dataTables-empty\" colspan=\"' + colspan + '\">' + message + \"</td>\"\n    }));\n  };\n  /**\r\n   * Columns API access\r\n   * @return {Object} new Columns instance\r\n   */\n\n\n  proto.columns = function (columns) {\n    return new Columns(this, columns);\n  };\n  /**\r\n   * Rows API access\r\n   * @return {Object} new Rows instance\r\n   */\n\n\n  proto.rows = function (rows) {\n    return new Rows(this, rows);\n  };\n  /**\r\n   * Add custom event listener\r\n   * @param  {String} event\r\n   * @param  {Function} callback\r\n   * @return {Void}\r\n   */\n\n\n  proto.on = function (event, callback) {\n    this.events = this.events || {};\n    this.events[event] = this.events[event] || [];\n    this.events[event].push(callback);\n  };\n  /**\r\n   * Remove custom event listener\r\n   * @param  {String} event\r\n   * @param  {Function} callback\r\n   * @return {Void}\r\n   */\n\n\n  proto.off = function (event, callback) {\n    this.events = this.events || {};\n    if (event in this.events === false) return;\n    this.events[event].splice(this.events[event].indexOf(callback), 1);\n  };\n  /**\r\n   * Fire custom event\r\n   * @param  {String} event\r\n   * @return {Void}\r\n   */\n\n\n  proto.emit = function (event) {\n    this.events = this.events || {};\n    if (event in this.events === false) return;\n\n    for (var i = 0; i < this.events[event].length; i++) {\n      this.events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  return DataTable;\n});","map":null,"metadata":{},"sourceType":"script"}